<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8">
<title>ğŸŒ¿ ×¢×•×œ× ×™×¨×•×§ - Lowpoly World</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#ui {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  color: white; text-shadow: 0 2px 8px rgba(0,0,0,0.5);
  text-align: center; pointer-events: none;
  font-size: 14px; letter-spacing: 1px;
}
#crosshair {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  width: 20px; height: 20px; pointer-events: none;
}
#crosshair::before, #crosshair::after {
  content: ''; position: absolute; background: rgba(255,255,255,0.8);
  border-radius: 2px;
}
#crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
#crosshair::after { width: 100%; height: 2px; top: 50%; transform: translateY(-50%); }
#instructions {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.9); text-align: center; font-size: 13px;
  text-shadow: 0 1px 4px rgba(0,0,0,0.6); pointer-events: none;
  background: rgba(0,0,0,0.2); padding: 8px 16px; border-radius: 20px;
  backdrop-filter: blur(4px);
}
#click-to-start {
  position: fixed; inset: 0; background: rgba(0,20,0,0.7);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  color: white; cursor: pointer; z-index: 100;
  backdrop-filter: blur(8px);
}
#click-to-start h1 { font-size: 48px; margin-bottom: 12px; text-shadow: 0 0 30px rgba(100,255,100,0.5); }
#click-to-start p { font-size: 18px; opacity: 0.8; }
#click-to-start .subtitle { font-size: 14px; opacity: 0.5; margin-top: 8px; }
</style>
</head>
<body>
<div id="click-to-start">
  <h1>ğŸŒ¿ ×¢×•×œ× ×™×¨×•×§</h1>
  <p>×œ×—×¥ ×›×“×™ ×œ×”×ª×—×™×œ ×œ×—×§×•×¨</p>
  <div class="subtitle">×œ×—×¥ ×›×“×™ ×œ× ×¢×•×œ ×¢×›×‘×¨ ×•×œ×”×ª×—×™×œ</div>
</div>
<div id="ui">ğŸŒ¿ Lowpoly World</div>
<div id="crosshair"></div>
<div id="instructions">WASD - ×ª× ×•×¢×” | ×¢×›×‘×¨ - ××‘×˜ | Space - ×§×¤×™×¦×” | Shift - ×¨×™×¦×” | F - ×¢×£ | ×œ×—×™×¦×” ×©×××œ - ×™×¨×™ | R - ×‘× ×” ××’×“×œ ×—×“×©</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// PLANET RADIUS & WORLD CONSTANTS
// ============================================================
const PLANET_R = 800;          // effective "flat" radius before curvature kicks in
const CHUNK_SIZE = 64;
const CHUNK_SEGS = 16;
const RENDER_CHUNKS = 5;       // chunks in each direction
const CELL = CHUNK_SIZE / CHUNK_SEGS;

// ============================================================
// SCENE SETUP
// ============================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0xC8E8FF, 200, 600);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 700);
camera.position.set(0, 5, 0);

// ============================================================
// LIGHTING  (noon sun)
// ============================================================
const ambient = new THREE.AmbientLight(0xfff5e0, 0.6);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xFFF8DC, 2.2);
sun.position.set(30, 120, 30);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far = 500;
sun.shadow.camera.left = sun.shadow.camera.bottom = -200;
sun.shadow.camera.right = sun.shadow.camera.top = 200;
sun.shadow.bias = -0.001;
scene.add(sun);

// Hemisphere fill
const hemi = new THREE.HemisphereLight(0x87CEEB, 0x4a7c59, 0.5);
scene.add(hemi);

// Sun disc in sky
const sunGeo = new THREE.SphereGeometry(8, 8, 8);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFDE7 });
const sunMesh = new THREE.Mesh(sunGeo, sunMat);
sunMesh.position.copy(sun.position).multiplyScalar(4);
scene.add(sunMesh);

// ============================================================
// NOISE  (simple deterministic)
// ============================================================
function hash(x, y) {
  let n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
  return n - Math.floor(n);
}
function smoothNoise(x, y) {
  const ix = Math.floor(x), iy = Math.floor(y);
  const fx = x - ix, fy = y - iy;
  const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
  const a = hash(ix, iy), b = hash(ix+1, iy);
  const c = hash(ix, iy+1), d = hash(ix+1, iy+1);
  return a + (b-a)*ux + (c-a)*uy + (d-a+a-b-c+b+c-d)*ux*uy - (c-a)*uy;
}
function fbm(x, y, oct=5) {
  let v=0, amp=1, freq=1, max=0;
  for(let i=0;i<oct;i++){v+=smoothNoise(x*freq,y*freq)*amp;max+=amp;amp*=0.5;freq*=2.1;}
  return v/max;
}
function getHeight(wx, wz) {
  const scale = 0.008;
  let h = fbm(wx*scale, wz*scale, 6);
  h = Math.pow(h, 1.4) * 28;
  // rolling hills
  h += fbm(wx*0.003, wz*0.003, 3) * 8;
  // flat valleys
  const valley = smoothNoise(wx*0.004, wz*0.004);
  if(valley < 0.35) h *= valley / 0.35 * 0.3;
  return h;
}

// Lake detection
function isLake(wx, wz) {
  const lx = Math.floor(wx / 120 + 0.5), lz = Math.floor(wz / 120 + 0.5);
  const seed = hash(lx * 17.3, lz * 31.7);
  if(seed < 0.18) {
    const cx = lx * 120, cz = lz * 120;
    const r = 15 + seed * 25;
    const dx = wx - cx, dz = wz - cz;
    return dx*dx + dz*dz < r*r;
  }
  return false;
}

// Path detection
function isPath(wx, wz) {
  // winding dirt paths using low-freq noise
  const pathNoise = smoothNoise(wx * 0.02, wz * 0.02 + 100);
  const offset = (pathNoise - 0.5) * 20;
  // main path: diagonal
  const dist1 = Math.abs((wx + wz * 0.7 + offset) % 180 - 90);
  const dist2 = Math.abs((wx * 0.6 - wz + offset * 0.8) % 200 - 100);
  return dist1 < 3.5 || dist2 < 2.8;
}

// ============================================================
// MATERIALS
// ============================================================
const matGrass = new THREE.MeshPhongMaterial({ color: 0x5aaf3c, flatShading: true, shininess: 0 });
const matDarkGrass = new THREE.MeshPhongMaterial({ color: 0x3d8a25, flatShading: true, shininess: 0 });
const matDirt = new THREE.MeshPhongMaterial({ color: 0xa0784a, flatShading: true, shininess: 0 });
const matPath = new THREE.MeshPhongMaterial({ color: 0xb8945a, flatShading: true, shininess: 0 });
const matRock = new THREE.MeshPhongMaterial({ color: 0x8a8a7a, flatShading: true, shininess: 5 });
const matRockDark = new THREE.MeshPhongMaterial({ color: 0x6a6a5a, flatShading: true, shininess: 5 });
const matTreeTrunk = new THREE.MeshPhongMaterial({ color: 0x7a5230, flatShading: true, shininess: 0 });
const matLeaf1 = new THREE.MeshPhongMaterial({ color: 0x3daa2a, flatShading: true, shininess: 0 });
const matLeaf2 = new THREE.MeshPhongMaterial({ color: 0x4dc535, flatShading: true, shininess: 0 });
const matLeaf3 = new THREE.MeshPhongMaterial({ color: 0x2d8a1a, flatShading: true, shininess: 0 });
const matFlower1 = new THREE.MeshPhongMaterial({ color: 0xf7c94b, flatShading: true, shininess: 10 });
const matFlower2 = new THREE.MeshPhongMaterial({ color: 0xe84393, flatShading: true, shininess: 10 });
const matFlower3 = new THREE.MeshPhongMaterial({ color: 0xff6b35, flatShading: true, shininess: 10 });
const matBush = new THREE.MeshPhongMaterial({ color: 0x2e7d32, flatShading: true, shininess: 0 });
const matBird = new THREE.MeshPhongMaterial({ color: 0x333333, flatShading: true, shininess: 0 });

// Water material with animation
const matWater = new THREE.MeshPhongMaterial({
  color: 0x1a7abf,
  transparent: true,
  opacity: 0.82,
  flatShading: true,
  shininess: 80,
  specular: 0x88ccff,
});

// ============================================================
// GEOMETRY HELPERS
// ============================================================
function jitter(geo, amount = 0.3) {
  const pos = geo.attributes.position;
  for(let i = 0; i < pos.count; i++) {
    pos.setXYZ(i,
      pos.getX(i) + (Math.random()-0.5)*amount,
      pos.getY(i) + (Math.random()-0.5)*amount*0.5,
      pos.getZ(i) + (Math.random()-0.5)*amount
    );
  }
  pos.needsUpdate = true;
  geo.computeVertexNormals();
  return geo;
}

function makeTree(x, y, z, scale=1, rng=Math.random) {
  const g = new THREE.Group();
  const h = (1.8 + rng(0)*1.2) * scale;
  const tg = new THREE.CylinderGeometry(0.1*scale, 0.18*scale, h, 5);
  const tm = new THREE.Mesh(tg, matTreeTrunk);
  tm.position.set(0, h/2, 0);
  tm.castShadow = true;
  g.add(tm);
  const leafMats = [matLeaf1, matLeaf2, matLeaf3];
  const layers = 3 + Math.floor(rng(1)*2);
  for(let i=0;i<layers;i++) {
    const r = (1.3 - i*0.22) * scale;
    const lh = (1.0 + rng(i*3+2)*0.3) * scale;
    const lg = new THREE.ConeGeometry(r, lh, 6);
    const lm = new THREE.Mesh(lg, leafMats[i%3]);
    lm.position.set(0, h + i * (lh * 0.52), 0);
    lm.rotation.y = (rng(i*3+3) + i*0.5)*Math.PI;
    lm.castShadow = true;
    g.add(lm);
  }
  g.position.set(x, y, z);
  return g;
}

function toFlat(geo) {
  // Only call toNonIndexed if geometry IS indexed (has an index buffer)
  const flat = geo.index ? geo.toNonIndexed() : geo;
  flat.computeVertexNormals();
  return flat;
}

function makeRockGeo(s) {
  return toFlat(new THREE.IcosahedronGeometry(s, 1));
}

function makeRock(x, y, z, rng) {
  const g = new THREE.Group();
  const r0=rng(0),r1=rng(1),r2=rng(2),r3=rng(3),r4=rng(4),
        r5=rng(5),r6=rng(6),r7=rng(7),r8=rng(8),r9=rng(9);

  const s      = 0.5 + r0 * 1.0;
  const scaleX = 0.9  + r3 * 0.5;
  const scaleY = 0.38 + r2 * 0.18;   // how flat the rock is (0.38-0.56)
  const scaleZ = 0.85 + r4 * 0.5;

  // The rock mesh is an IcosahedronGeometry centered at origin.
  // Its top is at +s*scaleY, its bottom is at -s*scaleY (in local space).
  // We want the BOTTOM to sit at terrain height, so we lift the mesh by s*scaleY.
  // Then we sink it INTO the ground by 30% of its height (heavier = bigger s = more sink).
  const halfH   = s * scaleY;          // half-height of rock after Y scale
  const sinkFrac = 0.25 + r0 * 0.20;  // 25%-45% of halfH sinks below ground
  const liftY   = halfH - halfH * sinkFrac;  // net lift = bottom + partial sink

  const col = r1 < 0.5 ? 0x8a8a7a : 0x6e7060;
  const mat = new THREE.MeshPhongMaterial({ color: col, flatShading: true, shininess: 3 });
  const rm  = new THREE.Mesh(makeRockGeo(s), mat);
  rm.scale.set(scaleX, scaleY, scaleZ);
  rm.rotation.y    = r5 * Math.PI * 2;
  rm.position.y    = liftY;    // sit on ground, partially embedded
  rm.castShadow    = true;
  rm.receiveShadow = true;
  g.add(rm);

  // Companion rock - same logic, positioned relative to group
  if(r6 < 0.55) {
    const s2       = s * (0.28 + r7 * 0.32);
    const scaleY2  = 0.4 + r8 * 0.18;
    const halfH2   = s2 * scaleY2;
    const liftY2   = halfH2 * 0.70;   // 30% sunk
    const offX     = (r8 - 0.5) * s * 1.4;
    const offZ     = (r9 - 0.5) * s * 1.4;
    // Get terrain height at companion position relative to group origin
    const groundOff = getHeight(x + offX, z + offZ) - getHeight(x, z);
    const mat2 = new THREE.MeshPhongMaterial({ color: 0x72726a, flatShading: true, shininess: 3 });
    const r2m  = new THREE.Mesh(makeRockGeo(s2), mat2);
    r2m.scale.set(1.0 + r7*0.3, scaleY2, 1.0 + r7*0.3);
    r2m.position.set(offX, groundOff + liftY2, offZ);
    r2m.rotation.y = r9 * Math.PI * 2;
    r2m.castShadow = true;
    g.add(r2m);
  }

  // Group origin = exact terrain height at rock center
  const groundY = getAvgHeight(x, z, s * 0.6);
  g.position.set(x, groundY, z);
  return g;
}

function makeBush(x, y, z, rng) {
  const g = new THREE.Group();
  const s = 0.5 + rng(0)*0.7;
  const cols = [0x2e7d32, 0x388e3c, 0x43a047, 0x1b5e20];
  const count = 2 + Math.floor(rng(1)*3);
  for(let i=0;i<count;i++) {
    const r = s*(0.45+rng(i*4+2)*0.45);
    const sg = new THREE.IcosahedronGeometry(r, 1);
    const col = cols[Math.floor(rng(i*4+3)*cols.length)];
    const sm = new THREE.Mesh(sg, new THREE.MeshPhongMaterial({color: col, flatShading: true, shininess: 0}));
    // Y: embed half-radius into ground so bushes sit on terrain
    sm.position.set((rng(i*4+4)-0.5)*s*1.2, r*0.45, (rng(i*4+5)-0.5)*s*1.2);
    sm.scale.y = 0.65 + rng(i*4+6)*0.25;
    sm.castShadow = true;
    g.add(sm);
  }
  g.position.set(x, y, z);
  return g;
}

function makeFlower(x, y, z, rng=Math.random) {
  const g = new THREE.Group();
  const flowerCols = [0xf7c94b, 0xe84393, 0xff6b35, 0xff4488, 0xffcc00, 0xff8833];
  const col = flowerCols[Math.floor(Math.random()*flowerCols.length)];
  const mat = new THREE.MeshPhongMaterial({ color: col, flatShading: true, shininess: 5 });
  const stemMat = new THREE.MeshPhongMaterial({ color: 0x3a8a2a, flatShading: true, shininess: 0 });

  const stemH = 0.25 + Math.random()*0.2;
  // Stem
  const stemG = new THREE.CylinderGeometry(0.018, 0.022, stemH, 4);
  const stemM = new THREE.Mesh(stemG, stemMat);
  stemM.position.y = stemH * 0.5;
  g.add(stemM);

  // Flower head: use OctahedronGeometry - 8 faces, naturally cute & lowpoly
  const headSize = 0.12 + Math.random()*0.09;
  const headGeo = new THREE.OctahedronGeometry(headSize, 0);
  headGeo.computeVertexNormals();
  const headM = new THREE.Mesh(headGeo, mat);
  headM.position.y = stemH + headSize * 0.7;
  headM.rotation.y = Math.random()*Math.PI;
  headM.scale.y = 0.75;
  g.add(headM);

  g.position.set(x, y, z);
  return g;
}

// ============================================================
// LAKE MESH
// ============================================================
const lakes = [];
function makeLake(cx, cz) {
  const key = `${Math.round(cx/5)}_${Math.round(cz/5)}`;
  if(lakes.find(l=>l.key===key)) return null;
  // find center height
  const baseH = getHeight(cx, cz);
  const r = 15 + hash(cx, cz)*25;
  const segs = 20;
  const wg = new THREE.CircleGeometry(r, segs);
  // jitter water verts slightly
  const pos = wg.attributes.position;
  for(let i=0;i<pos.count;i++) {
    pos.setX(i, pos.getX(i) + (Math.random()-0.5)*1.5);
    pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*1.5);
  }
  pos.needsUpdate = true;
  wg.computeVertexNormals();
  const wm = new THREE.Mesh(wg, matWater.clone());
  wm.rotation.x = -Math.PI/2;
  wm.position.set(cx, baseH - 0.5, cz);
  wm.receiveShadow = true;
  scene.add(wm);
  lakes.push({ key, mesh: wm, baseH });
  return wm;
}

// ============================================================
// BIRDS
// ============================================================
const birds = [];
for(let i=0;i<25;i++) {
  const b = new THREE.Group();
  // simple V-shape wings
  const wL = jitter(new THREE.ConeGeometry(0.25, 0.6, 3), 0.05);
  const wR = jitter(new THREE.ConeGeometry(0.25, 0.6, 3), 0.05);
  const mL = new THREE.Mesh(wL, matBird);
  const mR = new THREE.Mesh(wR, matBird);
  mL.rotation.z = Math.PI/2;
  mR.rotation.z = -Math.PI/2;
  mL.position.x = -0.3;
  mR.position.x = 0.3;
  b.add(mL); b.add(mR);
  const angle = Math.random()*Math.PI*2;
  const rad = 40 + Math.random()*80;
  b.position.set(Math.cos(angle)*rad, 20+Math.random()*30, Math.sin(angle)*rad);
  b.userData = {
    angle, rad,
    speed: 0.003 + Math.random()*0.004,
    height: 20+Math.random()*30,
    flapSpeed: 3+Math.random()*3,
    flapAmp: 0.4+Math.random()*0.3,
    t: Math.random()*100
  };
  scene.add(b);
  birds.push(b);
}

// ============================================================
// CHUNK SYSTEM
// ============================================================
const chunks = new Map();
const objects = new Map(); // decorations per chunk

function chunkKey(cx,cz) { return `${cx},${cz}`; }

function buildChunk(cx, cz) {
  const key = chunkKey(cx,cz);
  if(chunks.has(key)) return;

  const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;
  const N = CHUNK_SEGS;
  const verts = [], colors = [], indices = [];

  // Build height grid
  const heights = [];
  for(let z=0;z<=N;z++) for(let x=0;x<=N;x++) {
    const wx = ox + x*CELL, wz = oz + z*CELL;
    let h;
    if(isLake(wx, wz)) {
      h = getHeight(wx,wz) - 1.5;
    } else {
      h = getHeight(wx,wz);
    }
    heights.push(h);
  }

  // Build geometry
  for(let z=0;z<=N;z++) for(let x=0;x<=N;x++) {
    const wx = ox + x*CELL, wz = oz + z*CELL;
    const h = heights[z*(N+1)+x];
    verts.push(x*CELL, h, z*CELL);
    // color
    const lake = isLake(wx, wz);
    const path = !lake && isPath(wx, wz);
    let r,g,b;
    if(lake) { r=0.1;g=0.45;b=0.75; }
    else if(path) { r=0.68;g=0.52;b=0.28; }
    else if(h < 1.5) { r=0.6;g=0.45;b=0.3; } // sandy
    else { // grass variation
      const gv = 0.32 + fbm(wx*0.04,wz*0.04)*0.15;
      r=0.2; g=gv+0.1; b=0.15;
    }
    colors.push(r,g,b);
  }
  for(let z=0;z<N;z++) for(let x=0;x<N;x++) {
    const a=z*(N+1)+x, b=a+1, c=a+(N+1), d=c+1;
    indices.push(a,c,b, b,c,d);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
  geo.setIndex(indices);
  geo.computeVertexNormals();

  const mat = new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(ox, 0, oz);
  mesh.receiveShadow = true;
  mesh.castShadow = false;
  scene.add(mesh);
  chunks.set(key, mesh);

  // --- Physics collider for this terrain chunk (static trimesh) ---
  // IMPORTANT: Build vertices in CHUNK-LOCAL coordinates (same as the Three.js geometry),
  // and place the collider using translation (ox, oz). This keeps physics aligned with visuals.
  if(physWorld && RAPIER) {
    const posAttr = geo.getAttribute('position');
    const idxAttr = geo.index;

    // Positions in chunk-local space
    const verts = new Float32Array(posAttr.count * 3);
    for(let i = 0; i < posAttr.count; i++) {
      verts[i*3+0] = posAttr.getX(i);
      verts[i*3+1] = posAttr.getY(i);
      verts[i*3+2] = posAttr.getZ(i);
    }

    // Indices
    let indices;
    if(idxAttr) {
      indices = new Uint32Array(idxAttr.count);
      for(let i = 0; i < idxAttr.count; i++) indices[i] = idxAttr.getX(i);
    } else {
      indices = new Uint32Array(posAttr.count);
      for(let i = 0; i < posAttr.count; i++) indices[i] = i;
    }

    // Create collider directly (fixed body not needed)
    // trimesh expects vertices as Float32Array and indices as Uint32Array
    const colDesc = RAPIER.ColliderDesc.trimesh(verts, indices)
      .setTranslation(ox, 0, oz)
      .setRestitution(0.0)
      .setFriction(0.9);

    const collider = physWorld.createCollider(colDesc);
    terrainColliders.set(key, collider);
  }

  // Decorations - use world coords directly, no group offset
  const group = new THREE.Group();
  scene.add(group);
  const rng = (s) => { let v=hash(cx*17+s,cz*31+s*7); return v; };

  const decCount = 30 + Math.floor(rng(1)*20);
  for(let i=0;i<decCount;i++) {
    // World-space position of this decoration
    const tx = ox + rng(i*7+2) * CHUNK_SIZE;
    const tz = oz + rng(i*7+3) * CHUNK_SIZE;
    if(isLake(tx,tz) || isPath(tx,tz)) continue;
    const h = getHeight(tx, tz);   // exact height at this world pos
    if(h < 1) continue;
    const r4 = rng(i*7+4);
    let obj;
    // Seeded rng for this specific object - deterministic every rebuild
    const objRng = (k) => hash(cx*113 + i*71 + k*37, cz*97 + i*53 + k*19);
    if(r4 < 0.25) {
      obj = makeTree(tx, h, tz, 0.7+rng(i*7+5)*0.8, objRng);
    } else if(r4 < 0.45) {
      obj = makeRock(tx, h, tz, objRng);
    } else if(r4 < 0.65) {
      obj = makeBush(tx, h, tz, objRng);
    } else if(r4 < 0.9) {
      obj = makeFlower(tx, h, tz, objRng);
    }
    if(obj) group.add(obj);
  }

  // Lakes
  const lakeCheck = hash(cx*13.7, cz*29.3);
  if(lakeCheck < 0.2) {
    const lcx = ox + CHUNK_SIZE*0.5, lcz = oz + CHUNK_SIZE*0.5;
    if(!isPath(lcx,lcz)) makeLake(lcx, lcz);
  }

  // No position offset - objects are in world space already
  objects.set(key, group);

  // Create physics colliders for decorations in this chunk
  if(physWorld && RAPIER) addDecorationCollidersFromGroup(group);
}

function removeChunk(cx,cz) {
  const key = chunkKey(cx,cz);
  const mesh = chunks.get(key);
  if(mesh) { scene.remove(mesh); mesh.geometry.dispose(); chunks.delete(key); }
  const grp = objects.get(key);
  if(grp) { scene.remove(grp); objects.delete(key); }

  // Remove physics collider for this chunk
  if(physWorld && terrainColliders.has(key)) {
    physWorld.removeCollider(terrainColliders.get(key), true);
    terrainColliders.delete(key);
  }

  // Remove & rebuild decoration colliders lazily (next frame) to avoid stutter in the middle of movement.
  if(physWorld && RAPIER) decorationsDirty = true;
}

function updateChunks(px, pz) {
  // Use floor so we don't thrash chunk rebuilds around boundaries.
  // Rounding can cause rapid add/remove when hovering near edges -> stutter.
  const curCX = Math.floor(px / CHUNK_SIZE);
  const curCZ = Math.floor(pz / CHUNK_SIZE);
  const needed = new Set();
  const R = RENDER_CHUNKS;
  for(let dz=-R;dz<=R;dz++) for(let dx=-R;dx<=R;dx++) {
    if(dx*dx+dz*dz > R*R+1) continue;
    const cx=curCX+dx, cz=curCZ+dz;
    needed.add(chunkKey(cx,cz));
    buildChunk(cx,cz);
  }
  for(const [key] of chunks) {
    if(!needed.has(key)) removeChunk(...key.split(',').map(Number));
  }
}

// ============================================================
// INPUT & POINTER LOCK
// ============================================================
const keys = {};
let yaw = 0, pitch = 0;
let started = false;
let flyMode = false;
let isLocked = false;

renderer.domElement.style.cursor = 'crosshair';
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

// Click canvas = lock pointer (true FPS)
renderer.domElement.addEventListener('click', () => {
  if(!started) return;
  renderer.domElement.requestPointerLock();
});

document.getElementById('click-to-start').addEventListener('click', () => {
  started = true;
  document.getElementById('click-to-start').style.display = 'none';
  renderer.domElement.requestPointerLock();
});

document.addEventListener('pointerlockchange', () => {
  isLocked = document.pointerLockElement === renderer.domElement;
});
document.addEventListener('pointerlockerror', () => {
  console.warn('Pointer lock failed');
});

document.addEventListener('mousemove', e => {
  if(!isLocked) return;
  yaw   -= e.movementX * 0.002;
  pitch -= e.movementY * 0.002;
  pitch  = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, pitch));
});

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code === 'KeyF') { flyMode = !flyMode; }
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ============================================================
// HELPERS
// ============================================================
function getTerrainY(x, z) {
  if(isLake(x,z)) return getHeight(x,z) - 1.5;
  return getHeight(x,z);
}
function getAvgHeight(x, z, radius) {
  return Math.min(
    getHeight(x,z), getHeight(x+radius,z), getHeight(x-radius,z),
    getHeight(x,z+radius), getHeight(x,z-radius)
  );
}

// ============================================================
// PHYSICS CONSTANTS
// ============================================================
const SPEED       = 9;
const RUN_SPEED   = 20;
const FLY_SPEED   = 16;
const JUMP_VEL    = 8;
const GRAVITY_ACC = -22;
const EYE_HEIGHT  = 1.75;

// Player physics capsule (Rapier)
const PLAYER_RADIUS = 0.35;
const PLAYER_HALF_HEIGHT = 0.55; // half of cylinder part (excluding hemispheres)
const PLAYER_MASS = 70;

let velY      = 0; // legacy fallback when Rapier not ready
let isGrounded = false;
const playerPos = new THREE.Vector3(0, 10, 0);

// Rapier player body/collider
let playerBody = null;
let playerCollider = null;
let lastJumpTime = 0;

// Robust terrain sampler - samples a small grid and returns max
// to handle slopes: we want the HIGHEST point under the player's feet
function sampleGround(x, z) {
  const r = 0.3; // player foot radius
  return Math.max(
    getTerrainY(x,     z    ),
    getTerrainY(x + r, z    ),
    getTerrainY(x - r, z    ),
    getTerrainY(x,     z + r),
    getTerrainY(x,     z - r)
  );
}

// ============================================================
// ANIMATION LOOP
// ============================================================
let last = performance.now();
let time = 0;

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt  = Math.min((now - last) / 1000, 0.05);
  last = now;
  time += dt;

  if(started) {
    const spd  = keys['ShiftLeft']||keys['ShiftRight'] ? RUN_SPEED : SPEED;
    const fwdH = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
    const rgtH = new THREE.Vector3( Math.cos(yaw), 0, -Math.sin(yaw));

    if(flyMode) {
      // ---- FLY MODE ---- (no collisions)
      const fwd3 = new THREE.Vector3(
        -Math.sin(yaw)*Math.cos(pitch),
         Math.sin(pitch),
        -Math.cos(yaw)*Math.cos(pitch)
      );
      const mv = new THREE.Vector3();
      if(keys['KeyW']||keys['ArrowUp'])    mv.add(fwd3);
      if(keys['KeyS']||keys['ArrowDown'])  mv.sub(fwd3);
      if(keys['KeyA']||keys['ArrowLeft'])  mv.sub(rgtH);
      if(keys['KeyD']||keys['ArrowRight']) mv.add(rgtH);
      if(keys['Space']||keys['KeyE'])      mv.y += 1;
      if(keys['KeyQ'])                     mv.y -= 1;
      if(mv.lengthSq() > 0) mv.normalize().multiplyScalar(FLY_SPEED * dt);
      playerPos.add(mv);

      // Keep Rapier body aligned if it exists
      if(playerBody) {
        const bodyY = playerPos.y - (EYE_HEIGHT - PLAYER_RADIUS);
        if(typeof playerBody.setTranslation === 'function') {
          playerBody.setTranslation({ x: playerPos.x, y: bodyY, z: playerPos.z }, true);
        }
        if(typeof playerBody.setLinvel === 'function') playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
      }

    } else {
      // ---- WALK MODE ---- (Rapier-driven)
      if(physWorld && playerBody) {
        const mv = new THREE.Vector3();
        if(keys['KeyW']||keys['ArrowUp'])    mv.add(fwdH);
        if(keys['KeyS']||keys['ArrowDown'])  mv.sub(fwdH);
        if(keys['KeyA']||keys['ArrowLeft'])  mv.sub(rgtH);
        if(keys['KeyD']||keys['ArrowRight']) mv.add(rgtH);
        if(mv.lengthSq() > 0) mv.normalize();

        // Ground check via raycast
        const origin = playerBody.translation();
        const ray = new RAPIER.Ray({ x: origin.x, y: origin.y, z: origin.z }, { x: 0, y: -1, z: 0 });
        const maxToi = PLAYER_HALF_HEIGHT + PLAYER_RADIUS + 0.12;
        const hit = physWorld.castRay(ray, maxToi, true);
        isGrounded = !!hit;

        const cur = playerBody.linvel();
        const desired = { x: mv.x * spd, y: cur.y, z: mv.z * spd };

        if(keys['Space'] && isGrounded && (now - lastJumpTime) > 250) {
          desired.y = JUMP_VEL;
          lastJumpTime = now;
        }

        if(typeof playerBody.setLinvel === 'function') {
          playerBody.setLinvel(desired, true);
        } else if(typeof playerBody.setLinearVelocity === 'function') {
          playerBody.setLinearVelocity(desired, true);
        }

      } else {
        // Fallback old movement
        const mv = new THREE.Vector3();
        if(keys['KeyW']||keys['ArrowUp'])    mv.add(fwdH);
        if(keys['KeyS']||keys['ArrowDown'])  mv.sub(fwdH);
        if(keys['KeyA']||keys['ArrowLeft'])  mv.sub(rgtH);
        if(keys['KeyD']||keys['ArrowRight']) mv.add(rgtH);
        if(mv.lengthSq() > 0) mv.normalize().multiplyScalar(spd * dt);
        playerPos.x += mv.x;
        playerPos.z += mv.z;

        const groundY = sampleGround(playerPos.x, playerPos.z) + EYE_HEIGHT;
        velY += GRAVITY_ACC * dt;
        playerPos.y += velY * dt;
        if(playerPos.y < groundY) {
          playerPos.y = groundY;
          isGrounded = true;
          velY = 0;
        } else {
          isGrounded = false;
        }
        if(keys['Space'] && isGrounded) {
          velY = JUMP_VEL;
          isGrounded = false;
        }
      }
    }
  }

  camera.position.copy(playerPos);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = yaw;
  camera.rotation.x = pitch;

  document.getElementById('ui').textContent = flyMode
    ? 'ğŸ•Šï¸ ××¦×‘ ×˜×™×¡×” â€” F ×œ×‘×™×˜×•×œ | E/Space ×¢×œ×” | Q ×¨×“'
    : (isLocked ? 'ğŸŒ¿ Lowpoly World â€” ESC ×œ×©×—×¨×¨ ×¢×›×‘×¨' : 'ğŸŒ¿ ×œ×—×¥ ×œ×”× ×¢×œ×ª ×¢×›×‘×¨');

  updateChunks(playerPos.x, playerPos.z);

  for(const b of birds) {
    b.userData.t += dt;
    const d = b.userData;
    d.angle += d.speed;
    const tx = playerPos.x + Math.cos(d.angle)*d.rad;
    const tz = playerPos.z + Math.sin(d.angle)*d.rad;
    b.position.x += (tx - b.position.x)*0.01;
    b.position.z += (tz - b.position.z)*0.01;
    b.position.y = d.height + Math.sin(d.t*0.7)*3;
    b.lookAt(b.position.x+Math.cos(d.angle+Math.PI/2), b.position.y, b.position.z+Math.sin(d.angle+Math.PI/2));
    const fa = Math.sin(d.t*d.flapSpeed)*d.flapAmp;
    b.children[0].rotation.z = Math.PI/2 + fa;
    b.children[1].rotation.z = -Math.PI/2 - fa;
  }

  for(const lake of lakes) {
    lake.mesh.material.color.setHSL(0.57+Math.sin(time*0.5)*0.01, 0.75, 0.38+Math.sin(time)*0.02);
  }

  sun.position.set(playerPos.x+30, 120, playerPos.z+30);
  sunMesh.position.set(playerPos.x+120, 480, playerPos.z+120);

  // Step physics
  stepPhysics(dt);

  renderer.render(scene, camera);
}

// ============================================================
// RAPIER PHYSICS - loaded via dynamic ESM import
// ============================================================
let RAPIER = null;
let physWorld = null;
const rigidBodies = []; // {mesh, body}
const projectiles = []; // {mesh, body, born}

// Terrain colliders per chunk (static) so bullets don't fall through visual ground
const terrainColliders = new Map(); // key -> RAPIER.Collider

// Static colliders for decorations (trees/rocks/bushes) so projectiles/blocks collide with them.
// For performance and simplicity these are fixed colliders (no rigid bodies).
const decorationColliders = []; // RAPIER.Collider[]
let decorationsDirty = false;

// map from Three.js mesh -> rigid body for easy lookup
const meshToBody = new Map();

async function loadRapier() {
  // jsdelivr ESM URL for rapier3d-compat 0.14.0 (stable, widely cached)
  const R = await import('https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js');
  await R.init();
  RAPIER = R;

  // Create world
  physWorld = new RAPIER.World({ x: 0, y: -25, z: 0 });

  // NOTE:
  // We intentionally don't use a single flat ground plane.
  // Instead, each rendered terrain chunk gets its own static collider,
  // matching the visual mesh so projectiles don't fall through.

  console.log('âœ“ Rapier physics ready');

  // Create colliders for decorations already created before Rapier loaded
  clearDecorationColliders();
  for(const [, grp] of objects) addDecorationCollidersFromGroup(grp);

  initPlayerPhysics();

  buildTower();
}

function addPhysicsBox(mesh, hw, hh, hd, mass) {
  const t = mesh.position;
  const q = mesh.quaternion;
  let bodyDesc = mass === 0
    ? RAPIER.RigidBodyDesc.fixed()
    : RAPIER.RigidBodyDesc.dynamic();
  bodyDesc.setTranslation(t.x, t.y, t.z);
  bodyDesc.setRotation({ x: q.x, y: q.y, z: q.z, w: q.w });

  // Extra damping helps stacks settle instead of jittering/drifting.
  if(mass !== 0) {
    if(typeof bodyDesc.setLinearDamping === 'function') bodyDesc.setLinearDamping(0.15);
    if(typeof bodyDesc.setAngularDamping === 'function') bodyDesc.setAngularDamping(0.25);
  }

  const body = physWorld.createRigidBody(bodyDesc);
  const colDesc = RAPIER.ColliderDesc.cuboid(hw, hh, hd)
    .setRestitution(0.05)
    .setFriction(0.9);
  physWorld.createCollider(colDesc, body);
  rigidBodies.push({ mesh, body });
  meshToBody.set(mesh, body);
  return body;
}

function addPhysicsSphere(mesh, r, mass) {
  const t = mesh.position;
  const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
    .setTranslation(t.x, t.y, t.z);
  const body = physWorld.createRigidBody(bodyDesc);

  // Apply mass by setting density (Rapier uses collider density to derive mass).
  // Without this, bullets can feel like they "drop" immediately due to being too light.
  const density = Math.max(0.1, mass); // treat 'mass' as density-like scalar
  const colDesc = RAPIER.ColliderDesc.ball(r)
    .setDensity(density)
    .setRestitution(0.35)
    .setFriction(0.4);

  physWorld.createCollider(colDesc, body);
  rigidBodies.push({ mesh, body });
  return body;
}

function clearDecorationColliders() {
  if(!physWorld) return;
  for(const c of decorationColliders) {
    physWorld.removeCollider(c, true);
  }
  decorationColliders.length = 0;
}

function addDecorationCollidersFromGroup(group) {
  if(!physWorld || !RAPIER || !group) return;

  // Simple & fast: approximate each mesh in the decoration group with an oriented bounding box collider.
  // This is not perfect but gives solid physical interaction.
  const meshes = [];
  group.traverse(obj => { if(obj && obj.isMesh) meshes.push(obj); });

  for(const m of meshes) {
    const geo = m.geometry;
    if(!geo) continue;
    if(!geo.boundingBox) geo.computeBoundingBox();
    const bb = geo.boundingBox;
    if(!bb) continue;

    const size = new THREE.Vector3();
    bb.getSize(size);
    const center = new THREE.Vector3();
    bb.getCenter(center);

    // World transform
    const worldPos = new THREE.Vector3();
    m.getWorldPosition(worldPos);
    const worldQuat = new THREE.Quaternion();
    m.getWorldQuaternion(worldQuat);

    // Bounding box center in world space
    const worldCenter = center.clone().applyQuaternion(worldQuat).add(worldPos);

    // Use scaled half-extents (avoid zeros)
    const sx = m.scale.x || 1, sy = m.scale.y || 1, sz = m.scale.z || 1;
    const hx = Math.max(0.05, size.x * 0.5 * sx);
    const hy = Math.max(0.05, size.y * 0.5 * sy);
    const hz = Math.max(0.05, size.z * 0.5 * sz);

    const colDesc = RAPIER.ColliderDesc.cuboid(hx, hy, hz)
      .setTranslation(worldCenter.x, worldCenter.y, worldCenter.z)
      .setRotation({ x: worldQuat.x, y: worldQuat.y, z: worldQuat.z, w: worldQuat.w })
      .setRestitution(0.05)
      .setFriction(0.9);

    const col = physWorld.createCollider(colDesc);
    decorationColliders.push(col);
  }
}

function buildTower() {
  if(!RAPIER) return;
  // Remove old
  for(const rb of rigidBodies) { scene.remove(rb.mesh); physWorld.removeRigidBody(rb.body); }
  rigidBodies.length = 0;
  for(const p of projectiles) scene.remove(p.mesh);
  projectiles.length = 0;
  meshToBody.clear();

  // Ensure colliders exist for currently visible chunks (Rapier may load after terrain render)
  for(const [key, mesh] of chunks) {
    if(terrainColliders.has(key)) continue;
    const geo = mesh.geometry;
    const parts = key.split(',').map(Number);
    const cx = parts[0], cz = parts[1];
    const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;

    if(physWorld && RAPIER) {
      const posAttr = geo.getAttribute('position');
      const idxAttr = geo.index;

      const verts = new Float32Array(posAttr.count * 3);
      for(let i = 0; i < posAttr.count; i++) {
        verts[i*3+0] = posAttr.getX(i);
        verts[i*3+1] = posAttr.getY(i);
        verts[i*3+2] = posAttr.getZ(i);
      }

      let indices;
      if(idxAttr) {
        indices = new Uint32Array(idxAttr.count);
        for(let i = 0; i < idxAttr.count; i++) indices[i] = idxAttr.getX(i);
      } else {
        indices = new Uint32Array(posAttr.count);
        for(let i = 0; i < posAttr.count; i++) indices[i] = i;
      }

      const colDesc = RAPIER.ColliderDesc.trimesh(verts, indices)
        .setTranslation(ox, 0, oz)
        .setRestitution(0.0)
        .setFriction(0.9);
      const collider = physWorld.createCollider(colDesc);
      terrainColliders.set(key, collider);
    }
  }

  // Place tower in front of player
  const fwd = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
  const gx  = playerPos.x + fwd.x * 14;
  const gz  = playerPos.z + fwd.z * 14;
  const gy  = sampleGround(gx, gz);

  // Ground slab under tower (static)
  // Use a LEVEL foundation so the stack starts stable even if the terrain below is sloped.
  const SLAB_CLEARANCE = 0.55;
  const slabGeo = new THREE.BoxGeometry(12, 0.5, 6);
  const slabMat = new THREE.MeshPhongMaterial({ color: 0x8a7060, flatShading: true });
  const slabMesh = new THREE.Mesh(slabGeo, slabMat);
  slabMesh.receiveShadow = true;
  slabMesh.castShadow = true;
  slabMesh.position.set(gx, gy + 0.25 + SLAB_CLEARANCE, gz);
  slabMesh.rotation.set(0, 0, 0);
  scene.add(slabMesh);
  addPhysicsBox(slabMesh, 6, 0.25, 3, 0); // static

  // Colored blocks
  const bw = 0.6, bh = 0.6, bd = 0.6;
  const wide = 4, tall = 7;
  const BLOCK_CLEARANCE = 0.28;
  const cols = [0xe74c3c,0xe67e22,0xf1c40f,0x2ecc71,0x3498db,0x9b59b6,0x1abc9c,0xe91e63];
  for(let row = 0; row < tall; row++) {
    for(let col = 0; col < wide; col++) {
      const wx = gx + (col - (wide-1)/2) * (bw*2 + 0.05);
      const wy = gy + 0.3 + bh + row * (bh * 2 + 0.01) + SLAB_CLEARANCE + BLOCK_CLEARANCE;
      const color = cols[(row * wide + col) % cols.length];
      const geo  = new THREE.BoxGeometry(bw*2, bh*2, bd*2);
      const mat  = new THREE.MeshPhongMaterial({ color, flatShading: true, shininess: 8 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = mesh.receiveShadow = true;
      mesh.position.set(wx, wy, gz);
      scene.add(mesh);
      addPhysicsBox(mesh, bw, bh, bd, 3);
    }
  }
  console.log('âœ“ Tower built:', rigidBodies.length, 'bodies');
}

function shoot() {
  if(!RAPIER || !isLocked) return;

  const R = 0.25;
  const MUZZLE_SPEED = 65; // higher speed so it clearly goes forward

  // Direction from camera (includes pitch)
  const dir = new THREE.Vector3(
    -Math.sin(yaw) * Math.cos(pitch),
     Math.sin(pitch),
    -Math.cos(yaw) * Math.cos(pitch)
  ).normalize();

  // Spawn slightly in front of the camera, and not intersecting the player/ground
  const sp = camera.getWorldPosition(new THREE.Vector3())
    .addScaledVector(dir, 2.2);

  const geo = new THREE.SphereGeometry(R, 10, 7);
  const mat = new THREE.MeshPhongMaterial({ color: 0x1a1a2e, flatShading: true, shininess: 60 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true;
  mesh.position.copy(sp);
  scene.add(mesh);

  const body = addPhysicsSphere(mesh, R, 4);

  // Ensure it doesn't start "asleep" and add a small upward bias so it doesn't feel like it drops from you
  // Rapier JS API differs between builds. Support both:
  // - setLinvel({x,y,z}, wakeUp)
  // - setLinearVelocity({x,y,z}, wakeUp)
  // Also wake explicitly where supported.
  const linvel = {
    x: dir.x * MUZZLE_SPEED,
    y: (dir.y + 0.03) * MUZZLE_SPEED,
    z: dir.z * MUZZLE_SPEED,
  };

  if(typeof body.wakeUp === 'function') body.wakeUp();

  if(typeof body.setLinvel === 'function') {
    body.setLinvel(linvel, true);
  } else if(typeof body.setLinearVelocity === 'function') {
    body.setLinearVelocity(linvel, true);
  } else {
    console.warn('RigidBody has no linear-velocity setter. Available keys:', Object.keys(body));
  }

  // High CCD for fast projectile
  if(typeof body.enableCcd === 'function') body.enableCcd(true);

  projectiles.push({ mesh, body, born: performance.now() });
}

// Sync Three.js meshes with Rapier body transforms
function stepPhysics(dt) {
  if(!physWorld) return;

  // Rebuild decoration colliders in a controlled place (once) if chunks changed.
  if(decorationsDirty) {
    decorationsDirty = false;
    clearDecorationColliders();
    for(const [, g] of objects) addDecorationCollidersFromGroup(g);
  }
  physWorld.timestep = dt;
  physWorld.step();

  for(const rb of rigidBodies) {
    if(rb.body.isFixed()) continue;
    const t = rb.body.translation();
    const r = rb.body.rotation();
    rb.mesh.position.set(t.x, t.y, t.z);
    rb.mesh.quaternion.set(r.x, r.y, r.z, r.w);
  }

  // Sync player camera position from Rapier body
  if(playerBody) {
    const tp = playerBody.translation();
    // Body translation is capsule center; playerPos is eye position.
    playerPos.set(tp.x, tp.y + (EYE_HEIGHT - PLAYER_RADIUS), tp.z);
  }

  // Projectiles are kept (no auto-despawn).
  // Note: Keeping unlimited bodies forever can eventually hurt performance.
  // If you ever want a limit, we can keep the last N projectiles instead.
}
// ============================================================
// BOOT
// ============================================================
updateChunks(0, 0);
const startH = getTerrainY(0,0) + EYE_HEIGHT + 1;
playerPos.set(0, startH, 0);

// Shoot on left click
renderer.domElement.addEventListener('mousedown', e => {
  if(!started || !isLocked) return;
  if(e.button === 0) shoot();
});

// R = rebuild tower
document.addEventListener('keydown', e => {
  if(e.code === 'KeyR') buildTower();
});

// Load Rapier and build tower
function initPlayerPhysics() {
  if(!physWorld || !RAPIER) return;

  // Remove old player if any
  if(playerBody) {
    physWorld.removeRigidBody(playerBody);
    playerBody = null;
    playerCollider = null;
  }

  const start = playerPos.clone();
  const bodyY = start.y - (EYE_HEIGHT - PLAYER_RADIUS);

  const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(start.x, bodyY, start.z);

  // Prevent tipping over
  if(typeof bodyDesc.lockRotations === 'function') bodyDesc.lockRotations();

  // Damping for stable character control
  if(typeof bodyDesc.setLinearDamping === 'function') bodyDesc.setLinearDamping(4.0);
  if(typeof bodyDesc.setAngularDamping === 'function') bodyDesc.setAngularDamping(4.0);

  playerBody = physWorld.createRigidBody(bodyDesc);

  // Collider
  let colDesc;
  if(RAPIER.ColliderDesc.capsule) {
    colDesc = RAPIER.ColliderDesc.capsule(PLAYER_HALF_HEIGHT, PLAYER_RADIUS);
  } else {
    // Fallback
    colDesc = RAPIER.ColliderDesc.ball(PLAYER_RADIUS);
  }

  colDesc.setFriction(0.0).setRestitution(0.0);
  playerCollider = physWorld.createCollider(colDesc, playerBody);
}

loadRapier().catch(err => console.error('Rapier load failed:', err));

animate();
</script>
</body>
</html>

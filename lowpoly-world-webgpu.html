<!DOCTYPE html>
<html lang="he">

<head>
  <meta charset="UTF-8">
  <title>ğŸŒ¿ ×¢×•×œ× ×™×¨×•×§ - Lowpoly World (WebGPU)</title>
  <link rel="icon" href="data:,">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #5DADE2;
      font-family: 'Segoe UI', sans-serif;
    }

    canvas {
      display: block;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      text-align: center;
      pointer-events: none;
      font-size: 14px;
      letter-spacing: 1px;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 2px;
    }

    #crosshair::before {
      width: 2px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
    }

    #crosshair::after {
      width: 100%;
      height: 2px;
      top: 50%;
      transform: translateY(-50%);
    }

    #instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.9);
      text-align: center;
      font-size: 13px;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);
      pointer-events: none;
      background: rgba(0, 0, 0, 0.2);
      padding: 8px 16px;
      border-radius: 20px;
      backdrop-filter: blur(4px);
    }

    #underwater-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 140ms linear;
      background:
        radial-gradient(circle at 50% 42%, rgba(130, 205, 255, 0.12), rgba(24, 74, 116, 0.48)),
        linear-gradient(to bottom, rgba(120, 198, 245, 0.15), rgba(18, 57, 88, 0.42));
      mix-blend-mode: screen;
    }

    #click-to-start {
      position: fixed;
      inset: 0;
      background: rgba(0, 20, 0, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      cursor: pointer;
      z-index: 100;
      backdrop-filter: blur(8px);
    }

    #click-to-start h1 {
      font-size: 48px;
      margin-bottom: 12px;
      text-shadow: 0 0 30px rgba(100, 255, 100, 0.5);
    }

    #click-to-start p {
      font-size: 18px;
      opacity: 0.8;
    }

    #click-to-start .subtitle {
      font-size: 14px;
      opacity: 0.5;
      margin-top: 8px;
    }

    #season-selector {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.4);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
      color: white;
      font-family: sans-serif;
      font-size: 14px;
      min-width: 200px;
    }

    .season-btn {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      text-align: right;
      transition: all 0.2s;
    }

    .season-btn:hover {
      background: rgba(50, 150, 255, 0.5);
    }

    .season-btn.active {
      background: rgba(50, 150, 255, 0.8);
      border-color: white;
    }

    .slider-group {
      display: flex;
      flex-direction: column;
      margin-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      padding-top: 10px;
    }

    .slider-group label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }

    .slider-group input[type="range"] {
      width: 100%;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="click-to-start">
    <h1>ğŸŒ¿ ×¢×•×œ× ×™×¨×•×§</h1>
    <p>×œ×—×¥ ×›×“×™ ×œ×”×ª×—×™×œ ×œ×—×§×•×¨</p>
    <div class="subtitle">×œ×—×¥ ×›×“×™ ×œ× ×¢×•×œ ×¢×›×‘×¨ ×•×œ×”×ª×—×™×œ</div>
  </div>
  <div id="ui">ğŸŒ¿ Lowpoly World</div>
  <div id="crosshair"></div>
  <div id="instructions">
    <b>Movement:</b> WASD<br>
    <b>Jump:</b> Space<br>
    <b>Fly Mode:</b> F<br>
    <b>Look:</b> Mouse (Click to lock)
  </div>

  <div id="season-selector" dir="rtl">
    <button class="season-btn" data-season="Spring">ğŸŒ¸ ××‘×™×‘ (Spring)</button>
    <button class="season-btn active" data-season="Summer">â˜€ï¸ ×§×™×¥ (Summer)</button>
    <button class="season-btn" data-season="Autumn">ğŸ‚ ×¡×ª×™×• (Autumn)</button>
    <button class="season-btn" data-season="Winter">â„ï¸ ×—×•×¨×£ (Winter)</button>

    <div class="slider-group">
      <label>
        <span>×©×¢×” ×‘×™×•×:</span>
        <span id="time-display">12:00</span>
      </label>
      <input type="range" id="time-slider" min="0" max="23.99" step="0.01" value="12">

      <label style="margin-top: 10px;">
        <span>×™×•× ×‘×—×•×“×© (×™×¨×—):</span>
        <span id="day-display">15</span>
      </label>
      <input type="range" id="day-slider" min="1" max="30" step="1" value="15">
    </div>
  </div>
  <div id="underwater-overlay"></div>

  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
    "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
    "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from 'three/webgpu';
    import WebGPU from 'three/addons/capabilities/WebGPU.js';
    import {
      color,
      vec2,
      linearDepth,
      positionWorld,
      screenUV,
      viewportDepthTexture,
      viewportLinearDepth,
      viewportSharedTexture,
      mx_worley_noise_float,
      time,
      triplanarTexture,
      texture,
      normalWorld
    } from 'three/tsl';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    function showWebGPUError(msg) {
      const overlay = document.getElementById('click-to-start');
      overlay.style.display = 'flex';
      overlay.innerHTML = `
    <h1>WebGPU ×œ× ×–××™×Ÿ</h1>
    <p>${msg}</p>
    <div class="subtitle">× ×¡×” ×œ×”×¨×™×¥ ×“×¨×š localhost/https ×•×œ×¢×“×›×Ÿ ×“×¨×™×™×‘×¨/×“×¤×“×¤×Ÿ.</div>
  `;
      document.getElementById('ui').textContent = 'WebGPU ×œ× ×–××™×Ÿ';
    }

    if (WebGPU.isAvailable() === false) {
      showWebGPUError('×”×“×¤×“×¤×Ÿ ××• ×”×—×•××¨×” ×œ× ×ª×•××›×™× ×›×¨×’×¢ ×‘-WebGPU.');
      const details = WebGPU.getErrorMessage?.();
      if (details) document.body.appendChild(details);
      throw new Error('WebGPU is not available');
    }

    // ============================================================
    // PLANET RADIUS & WORLD CONSTANTS
    // ============================================================
    const QUALITY_PRESET = (new URLSearchParams(location.search).get('quality') || 'performance').toLowerCase();
    const HIGH_QUALITY = QUALITY_PRESET === 'high' || QUALITY_PRESET === 'ultra';
    const ENABLE_SHADOWS = true;  // Always enable shadows for better visuals
    const SHADOW_MAP_SIZE = HIGH_QUALITY ? 2048 : 1536;  // Larger shadow maps for sharper shadows
    const PIXEL_RATIO_CAP = HIGH_QUALITY ? 1.5 : 1.0;
    const LOOK_PRESET = (new URLSearchParams(location.search).get('look') || 'legacy').toLowerCase();
    const LEGACY_LOOK = LOOK_PRESET !== 'flat';
    const BUILD_TAG = 'webgpu-backdrop-water-box-v20';
    const AMBIENT_INTENSITY = LEGACY_LOOK ? 0.66 : 0.68;
    const SUN_INTENSITY = LEGACY_LOOK ? 2.9 : 2.35;
    const HEMI_INTENSITY = LEGACY_LOOK ? 0.62 : 0.58;
    const TONE_EXPOSURE = LEGACY_LOOK ? 1.18 : 1.12;  // Balanced summer exposure

    window.__buildInfo = {
      build: BUILD_TAG,
      quality: QUALITY_PRESET,
      look: LOOK_PRESET
    };
    console.log('[Build]', window.__buildInfo);
    document.title = `Lowpoly World WebGPU (${BUILD_TAG})`;

    let currentSeason = 'Summer'; // 'Spring', 'Summer', 'Autumn', 'Winter'
    let currentTimeOfDay = 12.0;    // 0 to <24
    let currentDayOfMonth = 15;     // 1 to 30

    const PLANET_R = 800;          // effective "flat" radius before curvature kicks in
    const CHUNK_SIZE = 64;
    const CHUNK_SEGS = 16;
    const RENDER_CHUNKS = HIGH_QUALITY ? 5 : 4; // chunks in each direction
    const CELL = CHUNK_SIZE / CHUNK_SEGS;

    // ============================================================
    // SCENE SETUP
    // ============================================================
    const SKY_BG_COLOR = new THREE.Color(0x5DADE2);  // Bright summer midday blue - clear sky
    const SKY_FOG_COLOR = new THREE.Color(0xAED6F1);  // Light horizon blue for fog gradient
    const SKY_FOG_NEAR = 200;
    const SKY_FOG_FAR = 600;
    const UNDERWATER_BG_COLOR = new THREE.Color(0x5d98bc);
    const UNDERWATER_FOG_COLOR = new THREE.Color(0x4a7ea6);
    const UNDERWATER_FOG_NEAR = 0.8;
    const UNDERWATER_FOG_FAR = 46;

    const scene = new THREE.Scene();
    scene.background = SKY_BG_COLOR.clone();
    scene.fog = new THREE.Fog(SKY_FOG_COLOR.clone(), SKY_FOG_NEAR, SKY_FOG_FAR);

    const renderer = new THREE.WebGPURenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, PIXEL_RATIO_CAP));
    renderer.shadowMap.enabled = ENABLE_SHADOWS;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = TONE_EXPOSURE;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 700);
    camera.position.set(0, 5, 0);
    const underwaterOverlay = document.getElementById('underwater-overlay');

    // ============================================================
    // LIGHTING
    // ============================================================
    let ambient = new THREE.AmbientLight(0xfff8e7, 0.5);
    scene.add(ambient);

    // Main Sun Light
    let sun = new THREE.DirectionalLight(0xFFFAF0, SUN_INTENSITY);
    sun.castShadow = ENABLE_SHADOWS;
    if (ENABLE_SHADOWS) {
      sun.shadow.mapSize.set(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE);
      sun.shadow.camera.near = 1;
      sun.shadow.camera.far = 1000;
      sun.shadow.camera.left = sun.shadow.camera.bottom = -400;
      sun.shadow.camera.right = sun.shadow.camera.top = 400;
      sun.shadow.bias = -0.0002;
      sun.shadow.normalBias = 0.02;
    }
    scene.add(sun);

    // Moon Light
    let moonLight = new THREE.DirectionalLight(0xAACCF0, 0); // Intensity set by updateLighting
    moonLight.castShadow = false; // Disable moon shadows for performance unless requested
    scene.add(moonLight);

    // Hemisphere fills
    let hemi = new THREE.HemisphereLight(0x5DADE2, 0x8B7355, HEMI_INTENSITY);
    scene.add(hemi);
    let skyFill = new THREE.HemisphereLight(0xAED6F1, 0x6f8a72, 0.28);
    scene.add(skyFill);

    // Sun disc in sky
    const sunGeo = new THREE.SphereGeometry(15, 16, 16);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
    let sunMesh = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sunMesh);

    // Sun glow halo effect
    const glowGeo = new THREE.SphereGeometry(25, 16, 16);
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0xFFF8DC, transparent: true, opacity: 0.25, blending: THREE.AdditiveBlending
    });
    let sunGlow = new THREE.Mesh(glowGeo, glowMat);
    scene.add(sunGlow);

    // Moon disc in sky
    const moonGeo = new THREE.SphereGeometry(12, 16, 16);
    const moonMat = new THREE.MeshBasicMaterial({ color: 0xE6F2FF });
    let moonMesh = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moonMesh);

    const moonGlowGeo = new THREE.SphereGeometry(20, 16, 16);
    const moonGlowMat = new THREE.MeshBasicMaterial({
      color: 0xAACCFF, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending
    });
    let moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
    scene.add(moonGlow);

    // ============================================================
    // NOISE  (simple deterministic)
    // ============================================================
    function hash(x, y) {
      let n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
      return n - Math.floor(n);
    }
    function smoothNoise(x, y) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
      const a = hash(ix, iy), b = hash(ix + 1, iy);
      const c = hash(ix, iy + 1), d = hash(ix + 1, iy + 1);
      return a + (b - a) * ux + (c - a) * uy + (d - a + a - b - c + b + c - d) * ux * uy - (c - a) * uy;
    }
    function fbm(x, y, oct = 5) {
      let v = 0, amp = 1, freq = 1, max = 0;
      for (let i = 0; i < oct; i++) { v += smoothNoise(x * freq, y * freq) * amp; max += amp; amp *= 0.5; freq *= 2.1; }
      return v / max;
    }
    function getHeight(wx, wz) {
      const scale = 0.008;
      let h = fbm(wx * scale, wz * scale, 6);
      h = Math.pow(h, 1.4) * 28;
      // rolling hills
      h += fbm(wx * 0.003, wz * 0.003, 3) * 8;
      // flat valleys
      const valley = smoothNoise(wx * 0.004, wz * 0.004);
      if (valley < 0.35) h *= valley / 0.35 * 0.3;
      return h;
    }

    // Lake detection
    function isLake(wx, wz) {
      return getLakeAtWater(wx, wz) !== null;
    }

    // Path detection
    function isPath(wx, wz) {
      // winding dirt paths using low-freq noise
      const pathNoise = smoothNoise(wx * 0.02, wz * 0.02 + 100);
      const offset = (pathNoise - 0.5) * 20;
      // main path: diagonal
      const dist1 = Math.abs((wx + wz * 0.7 + offset) % 180 - 90);
      const dist2 = Math.abs((wx * 0.6 - wz + offset * 0.8) % 200 - 100);
      return dist1 < 3.5 || dist2 < 2.8;
    }

    // ============================================================
    // MATERIALS
    // ============================================================
    const matGrass = new THREE.MeshPhongMaterial({ color: 0x5aaf3c, flatShading: true, shininess: 0 });
    const matDarkGrass = new THREE.MeshPhongMaterial({ color: 0x3d8a25, flatShading: true, shininess: 0 });
    const matDirt = new THREE.MeshPhongMaterial({ color: 0xa0784a, flatShading: true, shininess: 0 });
    const matPath = new THREE.MeshPhongMaterial({ color: 0xb8945a, flatShading: true, shininess: 0 });
    const matRock = new THREE.MeshPhongMaterial({ color: 0x8a8a7a, flatShading: true, shininess: 5 });
    const matRockDark = new THREE.MeshPhongMaterial({ color: 0x6a6a5a, flatShading: true, shininess: 5 });
    const matTreeTrunk = new THREE.MeshPhongMaterial({ color: 0x7a5230, flatShading: true, shininess: 0 });
    const matLeaf1 = new THREE.MeshPhongMaterial({ color: 0x3daa2a, flatShading: true, shininess: 0 });
    const matLeaf2 = new THREE.MeshPhongMaterial({ color: 0x4dc535, flatShading: true, shininess: 0 });
    const matLeaf3 = new THREE.MeshPhongMaterial({ color: 0x2d8a1a, flatShading: true, shininess: 0 });
    const matFlower1 = new THREE.MeshPhongMaterial({ color: 0xf7c94b, flatShading: true, shininess: 10 });
    const matFlower2 = new THREE.MeshPhongMaterial({ color: 0xe84393, flatShading: true, shininess: 10 });
    const matFlower3 = new THREE.MeshPhongMaterial({ color: 0xff6b35, flatShading: true, shininess: 10 });
    const matBush = new THREE.MeshPhongMaterial({ color: 0x2e7d32, flatShading: true, shininess: 0 });
    const matBird = new THREE.MeshPhongMaterial({ color: 0x333333, flatShading: true, shininess: 0 });

    // Water material - exact implementation from lake_scene (15).html
    function makeBackdropWaterMaterial() {
      const t = time.mul(0.8);
      const floorUV = positionWorld.xzy;
      const waterLayer0 = mx_worley_noise_float(floorUV.mul(4).add(t));
      const waterLayer1 = mx_worley_noise_float(floorUV.mul(2).add(t));
      const waterIntensity = waterLayer0.mul(waterLayer1);
      const waterColor = waterIntensity.mul(1.4).mix(color(0x0487e2), color(0x74ccf4));
      const depth = linearDepth();
      // Compute depth of the water and invert it (oneMinus) as in the original example
      const depthWater = viewportLinearDepth.sub(depth).oneMinus();
      const depthEffect = depthWater.remapClamp(-0.002, 0.04);
      const refractionUV = screenUV.add(vec2(0, waterIntensity.mul(0.1)));
      const depthTestForRefraction = linearDepth(viewportDepthTexture(refractionUV)).sub(depth);
      const depthRefraction = depthTestForRefraction.remapClamp(0, 0.1);
      const finalUV = depthTestForRefraction.lessThan(0).select(screenUV, refractionUV);
      const viewportTexture = viewportSharedTexture(finalUV);
      const waterMaterial = new THREE.MeshBasicNodeMaterial();
      // Assign the node-based color and backdrop nodes from the original example
      waterMaterial.colorNode = waterColor;
      waterMaterial.backdropNode = depthEffect.mix(
        viewportSharedTexture(),
        viewportTexture.mul(depthRefraction.mix(1, waterColor))
      );
      waterMaterial.backdropAlphaNode = depthRefraction.oneMinus();
      // Important: prevent the water mesh from writing to the depth buffer
      waterMaterial.depthWrite = false;
      waterMaterial.transparent = true;
      // Render both sides of the water surface
      waterMaterial.side = THREE.DoubleSide;
      return waterMaterial;
    }

    const sharedBackdropWaterMaterial = makeBackdropWaterMaterial();
    // ============================================================
    // GEOMETRY HELPERS
    // ============================================================
    function jitter(geo, amount = 0.3) {
      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        pos.setXYZ(i,
          pos.getX(i) + (Math.random() - 0.5) * amount,
          pos.getY(i) + (Math.random() - 0.5) * amount * 0.5,
          pos.getZ(i) + (Math.random() - 0.5) * amount
        );
      }
      pos.needsUpdate = true;
      geo.computeVertexNormals();
      return geo;
    }

    function makeTree(x, y, z, scale = 1, type = 0, rng = Math.random) {
      const g = new THREE.Group();
      g.position.set(x, y, z);

      const leafMats = [matLeaf1, matLeaf2, matLeaf3];

      if (type === 0) {
        // --- 0: Standard Stylized Angular Tree ---
        const trunkH1 = (0.8 + rng(0) * 0.6) * scale;
        const trunkH2 = (1.0 + rng(1) * 0.6) * scale;
        const r_bottom = 0.18 * scale;
        const r_mid = 0.12 * scale;
        const r_top = 0.05 * scale;

        // Bottom trunk
        const tg1 = new THREE.CylinderGeometry(r_mid, r_bottom, trunkH1, 5);
        const tm1 = new THREE.Mesh(tg1, matTreeTrunk);
        tm1.position.set(0, trunkH1 / 2, 0);
        tm1.castShadow = true;
        g.add(tm1);

        // Top trunk (angled)
        const angle = (rng(2) - 0.5) * 0.8;
        const dirX = Math.cos(rng(3) * Math.PI * 2);
        const dirZ = Math.sin(rng(3) * Math.PI * 2);

        const tg2 = new THREE.CylinderGeometry(r_top, r_mid, trunkH2, 5);
        const tm2 = new THREE.Mesh(tg2, matTreeTrunk);
        tm2.position.set(0, trunkH2 / 2, 0);
        tm2.castShadow = true;

        const pivot = new THREE.Group();
        pivot.position.set(0, trunkH1 - 0.05, 0);
        const axis = new THREE.Vector3(dirZ, 0, -dirX).normalize();
        pivot.setRotationFromAxisAngle(axis, angle);
        pivot.add(tm2);
        g.add(pivot);

        const addLeafClump = (parent, offsetY, clumpScale, mIndex) => {
          if (currentSeason === 'Winter') return; // Bare branches in winter
          const rad = (0.6 + rng(mIndex * 10) * 0.4) * scale * clumpScale;
          const lg = new THREE.IcosahedronGeometry(rad, 0);
          const lm = new THREE.Mesh(lg, leafMats[mIndex % 3]);
          lm.position.set(0, offsetY, 0);
          lm.rotation.set(rng(mIndex * 10 + 1) * Math.PI, rng(mIndex * 10 + 2) * Math.PI, rng(mIndex * 10 + 3) * Math.PI);
          lm.castShadow = true;
          lm.scale.y = 0.8 + rng(mIndex * 10 + 4) * 0.4;
          parent.add(lm);
        };

        addLeafClump(pivot, trunkH2 - 0.1, 1.4, 0); // Main canopy

        const branchCount = 1 + Math.floor(rng(4) * 2);
        for (let i = 0; i < branchCount; i++) {
          const bH = (0.6 + rng(5 + i * 4) * 0.5) * scale;
          const bA = 0.6 + rng(6 + i * 4) * 0.4;
          const bDirX = Math.cos(rng(7 + i * 4) * Math.PI * 2);
          const bDirZ = Math.sin(rng(7 + i * 4) * Math.PI * 2);

          const bg = new THREE.CylinderGeometry(0.02 * scale, 0.08 * scale, bH, 4);
          const bm = new THREE.Mesh(bg, matTreeTrunk);
          bm.position.set(0, bH / 2, 0);
          bm.castShadow = true;

          const bpivot = new THREE.Group();
          if (rng(8 + i * 4) > 0.5) {
            bpivot.position.set(0, trunkH2 * (0.3 + rng(9 + i * 4) * 0.5), 0);
            pivot.add(bpivot);
          } else {
            bpivot.position.set(0, trunkH1 * (0.4 + rng(9 + i * 4) * 0.5), 0);
            g.add(bpivot);
          }
          const bAxis = new THREE.Vector3(bDirZ, 0, -bDirX).normalize();
          bpivot.setRotationFromAxisAngle(bAxis, bA);
          bpivot.add(bm);

          addLeafClump(bpivot, bH - 0.05, 1.0, i + 1);
        }

      } else if (type === 1) {
        // --- 1: Pine / Cypress Tree ---
        // Tall, narrow, tapered layers
        const trunkH = (0.5 + rng(0) * 0.5) * scale;
        const r_bottom = 0.15 * scale;
        const tg = new THREE.CylinderGeometry(r_bottom * 0.6, r_bottom, trunkH, 5);
        const tm = new THREE.Mesh(tg, matTreeTrunk);
        tm.position.set(0, trunkH / 2, 0);
        tm.castShadow = true;
        g.add(tm);

        const layers = 4 + Math.floor(rng(1) * 3);
        let currentY = trunkH * 0.8;
        let pRadius = (1.2 + rng(2) * 0.4) * scale;

        for (let i = 0; i < layers; i++) {
          const lH = (1.5 + rng(3 + i * 2) * 0.5) * scale;
          // Pine layers uses cone or tapered cylinder
          const pg = new THREE.CylinderGeometry(pRadius * 0.3, pRadius, lH, 6);
          const pm = new THREE.Mesh(pg, leafMats[i % 3]);
          pm.position.set(0, currentY + lH / 2, 0);
          // slight random tilt
          pm.rotation.x = (rng(4 + i * 3) - 0.5) * 0.1;
          pm.rotation.z = (rng(5 + i * 3) - 0.5) * 0.1;
          pm.rotation.y = rng(6 + i * 3) * Math.PI;
          pm.castShadow = true;
          g.add(pm);

          currentY += lH * 0.6; // overlap
          pRadius *= (0.7 + rng(7 + i) * 0.1); // taper
        }

      } else if (type === 2) {
        // --- 2: Round / Bushy Tree ---
        // Shorter trunk, large spherical/clustered canopy
        const trunkH = (1.0 + rng(0) * 0.5) * scale;
        const r_bottom = 0.2 * scale;
        const tg = new THREE.CylinderGeometry(r_bottom * 0.7, r_bottom, trunkH, 5);
        const tm = new THREE.Mesh(tg, matTreeTrunk);
        tm.position.set(0, trunkH / 2, 0);
        tm.castShadow = true;
        g.add(tm);

        // Canopy cluster
        if (currentSeason !== 'Winter') {
          const clumpCount = 3 + Math.floor(rng(1) * 3);
          const cluster = new THREE.Group();
          cluster.position.set(0, trunkH * 0.9, 0);

          for (let i = 0; i < clumpCount; i++) {
            const radius = (1.0 + rng(2 + i * 3) * 0.5) * scale;
            const geo = new THREE.IcosahedronGeometry(radius, 1);
            // Random offset
            const ox = (rng(3 + i * 3) - 0.5) * 1.2 * scale;
            const oy = rng(4 + i * 3) * 1.0 * scale;
            const oz = (rng(5 + i * 3) - 0.5) * 1.2 * scale;

            const mesh = new THREE.Mesh(geo, leafMats[i % 3]);
            mesh.position.set(ox, oy, oz);
            mesh.rotation.y = rng(6 + i * 3) * Math.PI;
            mesh.scale.y = 0.8 + rng(7 + i * 3) * 0.4;
            mesh.castShadow = true;
            cluster.add(mesh);
          }
          g.add(cluster);
        } else {
          // Add a couple of bare branches in winter
          for (let i = 0; i < 2; i++) {
            const bH = (0.4 + rng(i) * 0.3) * scale;
            const bg = new THREE.CylinderGeometry(0.02 * scale, 0.05 * scale, bH, 4);
            const bm = new THREE.Mesh(bg, matTreeTrunk);
            bm.position.set(0, bH / 2, 0);
            bm.castShadow = true;
            const bpivot = new THREE.Group();
            bpivot.position.set(0, trunkH * (0.6 + rng(i + 10) * 0.3), 0);
            const bAxis = new THREE.Vector3(Math.cos(rng(i + 20) * Math.PI * 2), 0, Math.sin(rng(i + 20) * Math.PI * 2)).normalize();
            bpivot.setRotationFromAxisAngle(bAxis, 0.5 + rng(i + 30) * 0.5);
            bpivot.add(bm);
            g.add(bpivot);
          }
        }
      }

      return g;
    }

    function toFlat(geo) {
      // Only call toNonIndexed if geometry IS indexed (has an index buffer)
      const flat = geo.index ? geo.toNonIndexed() : geo;
      flat.computeVertexNormals();
      return flat;
    }

    function makeRockGeo(s) {
      return toFlat(new THREE.IcosahedronGeometry(s, 1));
    }

    function makeRock(x, y, z, rng) {
      const g = new THREE.Group();
      const r0 = rng(0), r1 = rng(1), r2 = rng(2), r3 = rng(3), r4 = rng(4),
        r5 = rng(5), r6 = rng(6), r7 = rng(7), r8 = rng(8), r9 = rng(9);

      const s = 0.5 + r0 * 1.0;
      const scaleX = 0.9 + r3 * 0.5;
      const scaleY = 0.38 + r2 * 0.18;   // how flat the rock is (0.38-0.56)
      const scaleZ = 0.85 + r4 * 0.5;

      // The rock mesh is an IcosahedronGeometry centered at origin.
      // Its top is at +s*scaleY, its bottom is at -s*scaleY (in local space).
      // We want the BOTTOM to sit at terrain height, so we lift the mesh by s*scaleY.
      // Then we sink it INTO the ground by 30% of its height (heavier = bigger s = more sink).
      const halfH = s * scaleY;          // half-height of rock after Y scale
      const sinkFrac = 0.25 + r0 * 0.20;  // 25%-45% of halfH sinks below ground
      const liftY = halfH - halfH * sinkFrac;  // net lift = bottom + partial sink

      const col = r1 < 0.5 ? 0x8a8a7a : 0x6e7060;
      const mat = new THREE.MeshPhongMaterial({ color: col, flatShading: true, shininess: 3 });
      const rm = new THREE.Mesh(makeRockGeo(s), mat);
      rm.scale.set(scaleX, scaleY, scaleZ);
      rm.rotation.y = r5 * Math.PI * 2;
      rm.position.y = liftY;    // sit on ground, partially embedded
      rm.castShadow = true;
      rm.receiveShadow = true;
      g.add(rm);

      // Companion rock - same logic, positioned relative to group
      if (r6 < 0.55) {
        const s2 = s * (0.28 + r7 * 0.32);
        const scaleY2 = 0.4 + r8 * 0.18;
        const halfH2 = s2 * scaleY2;
        const liftY2 = halfH2 * 0.70;   // 30% sunk
        const offX = (r8 - 0.5) * s * 1.4;
        const offZ = (r9 - 0.5) * s * 1.4;
        // Get terrain height at companion position relative to group origin
        const groundOff = getMeshHeight(x + offX, z + offZ) - getMeshHeight(x, z);
        const mat2 = new THREE.MeshPhongMaterial({ color: 0x72726a, flatShading: true, shininess: 3 });
        const r2m = new THREE.Mesh(makeRockGeo(s2), mat2);
        r2m.scale.set(1.0 + r7 * 0.3, scaleY2, 1.0 + r7 * 0.3);
        r2m.position.set(offX, groundOff + liftY2, offZ);
        r2m.rotation.y = r9 * Math.PI * 2;
        r2m.castShadow = true;
        g.add(r2m);
      }

      // Group origin = exact terrain height at rock center
      const groundY = getMeshAvgHeight(x, z, s * 0.6);
      g.position.set(x, groundY, z);
      return g;
    }

    function makeBush(x, y, z, rng) {
      const g = new THREE.Group();
      const s = 0.5 + rng(0) * 0.7;
      const cols = [0x2e7d32, 0x388e3c, 0x43a047, 0x1b5e20];
      const count = 2 + Math.floor(rng(1) * 3);

      for (let i = 0; i < count; i++) {
        const r = s * (0.45 + rng(i * 4 + 2) * 0.45);
        // Detail 0 for angular low-poly styled bush clumps
        const sg = new THREE.IcosahedronGeometry(r, 0);
        // We use the seasonal leaf materials to ensure bushes update colors with the seasons
        const leafMats = [matLeaf1, matLeaf2, matLeaf3];
        const sm = new THREE.Mesh(sg, leafMats[i % 3]);

        // Y: embed half-radius into ground so bushes sit on terrain
        sm.position.set((rng(i * 4 + 4) - 0.5) * s * 1.2, r * 0.45, (rng(i * 4 + 5) - 0.5) * s * 1.2);

        // Non-uniform scaling for organic angular shapes
        sm.scale.y = 0.65 + rng(i * 4 + 6) * 0.25;
        sm.rotation.set(rng(i * 4 + 7) * Math.PI, rng(i * 4 + 8) * Math.PI, rng(i * 4 + 9) * Math.PI);
        sm.castShadow = true;
        g.add(sm);
      }
      g.position.set(x, y, z);
      return g;
    }

    function makeFlower(x, y, z, rng = Math.random) {
      const g = new THREE.Group();
      const flowerCols = [0xf7c94b, 0xe84393, 0xff6b35, 0xff4488, 0xffcc00, 0xff8833];
      const col = flowerCols[Math.floor(Math.random() * flowerCols.length)];
      const mat = new THREE.MeshPhongMaterial({ color: col, flatShading: true, shininess: 5 });
      const stemMat = new THREE.MeshPhongMaterial({ color: 0x3a8a2a, flatShading: true, shininess: 0 });

      const stemH = 0.25 + Math.random() * 0.2;
      // Stem
      const stemG = new THREE.CylinderGeometry(0.018, 0.022, stemH, 4);
      const stemM = new THREE.Mesh(stemG, stemMat);
      stemM.position.y = stemH * 0.5;
      g.add(stemM);

      // Flower head: use OctahedronGeometry - 8 faces, naturally cute & lowpoly
      const headSize = 0.12 + Math.random() * 0.09;
      const headGeo = new THREE.OctahedronGeometry(headSize, 0);
      headGeo.computeVertexNormals();
      const headM = new THREE.Mesh(headGeo, mat);
      headM.position.y = stemH + headSize * 0.7;
      headM.rotation.y = Math.random() * Math.PI;
      headM.scale.y = 0.75;
      g.add(headM);

      g.position.set(x, y, z);
      return g;
    }

    // ============================================================
    // LAKE MESH
    // ============================================================
    const LAKE_CELL = 120;
    const LAKE_MAX_RADIUS = 40;
    const LAKE_EDGE_SOFTNESS = 0.16;
    const LAKE_WATER_FOOTPRINT_SCALE = 1.05;
    const LAKE_MIN_VISIBLE_DEPTH = 0.55;
    const lakes = new Map(); // lakeKey -> { surface, volume }
    const lakeDescriptors = new Map(); // lakeKey -> descriptor | null

    function smoothstep01(t) {
      const x = Math.min(1, Math.max(0, t));
      return x * x * (3 - 2 * x);
    }

    function lakeDepthAtPoint(lake, wx, wz) {
      const dx = wx - lake.cx;
      const dz = wz - lake.cz;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist >= lake.r) return 0;
      const edgeStart = lake.r * (1 - LAKE_EDGE_SOFTNESS);
      const edgeT = (dist - edgeStart) / Math.max(0.0001, lake.r - edgeStart);
      const fade = 1 - smoothstep01(edgeT);
      return lake.depth * fade;
    }

    function getLakeBottomHeightForDescriptor(lake, wx, wz) {
      return getHeight(wx, wz) - lakeDepthAtPoint(lake, wx, wz);
    }

    function getLakeWaterRadius(lake) {
      return lake.r * LAKE_WATER_FOOTPRINT_SCALE;
    }

    function isPointInsideLakeWater(lake, wx, wz) {
      if (!lake) return false;
      const waterRadius = getLakeWaterRadius(lake);
      const dx = Math.abs(wx - lake.cx);
      const dz = Math.abs(wz - lake.cz);
      return dx <= waterRadius && dz <= waterRadius;
    }

    function computeLakeProfile(lake) {
      const rimSamples = HIGH_QUALITY ? 72 : 56;
      const rimRadius = lake.r + CELL * 0.8;
      let spillHeight = Infinity;
      for (let i = 0; i < rimSamples; i++) {
        const a = (i / rimSamples) * Math.PI * 2;
        const wx = lake.cx + Math.cos(a) * rimRadius;
        const wz = lake.cz + Math.sin(a) * rimRadius;
        spillHeight = Math.min(spillHeight, getHeight(wx, wz));
      }

      let floorMin = Infinity;
      let floorSum = 0;
      let floorCount = 0;
      let groundSum = 0;  // Also track original ground height (before lake depth)
      const radialSteps = 6;
      for (let rStep = 0; rStep <= radialSteps; rStep++) {
        const rr = (rStep / radialSteps) * (lake.r * 0.95);
        const ringCount = Math.max(10, Math.round((HIGH_QUALITY ? 54 : 40) * (0.35 + 0.65 * (rr / lake.r))));
        for (let i = 0; i < ringCount; i++) {
          const a = (i / ringCount) * Math.PI * 2;
          const wx = lake.cx + Math.cos(a) * rr;
          const wz = lake.cz + Math.sin(a) * rr;
          const h = getLakeBottomHeightForDescriptor(lake, wx, wz);
          const groundH = getHeight(wx, wz);  // Original ground height
          floorMin = Math.min(floorMin, h);
          floorSum += h;
          groundSum += groundH;
          floorCount++;
        }
      }

      const floorMean = floorSum / Math.max(1, floorCount);
      const groundMean = groundSum / Math.max(1, floorCount);  // Average ground height in lake area

      // CRITICAL FIX: Water level must be BELOW the average ground level
      // This prevents water from floating above the terrain
      const maxAllowed = Math.min(spillHeight - 0.05, groundMean - 0.5);
      const targetDepth = THREE.MathUtils.clamp((spillHeight - floorMin) * 0.82, 0.65, lake.depth + 0.35);

      let level = floorMin + targetDepth;
      level = Math.max(level, floorMean + 0.18);
      level = Math.max(level, floorMin + 0.35);
      level = Math.min(level, maxAllowed);

      if (!Number.isFinite(level)) level = getHeight(lake.cx, lake.cz) - 0.2;

      let bottom = Math.min(floorMin, level - 0.95);
      if (!Number.isFinite(bottom)) bottom = level - 1.1;
      bottom = Math.min(bottom, level - 0.3);

      return { level, bottom, floorMin, floorMean, spillHeight };
    }

    function getLakeDescriptor(lx, lz) {
      const key = `${lx},${lz}`;
      if (lakeDescriptors.has(key)) return lakeDescriptors.get(key);

      const seed = hash(lx * 17.3, lz * 31.7);
      if (seed >= 0.18) {
        lakeDescriptors.set(key, null);
        return null;
      }

      const cx = lx * LAKE_CELL;
      const cz = lz * LAKE_CELL;
      const r = 15 + seed * 25;
      const depth = (2.3 + seed * 1.4) * 3;  // 3x deeper lakes
      const descriptor = { key, lx, lz, cx, cz, r, depth, level: 0, bottom: 0 };
      const profile = computeLakeProfile(descriptor);

      if (profile.spillHeight <= profile.floorMin + 1.5) {
        lakeDescriptors.set(key, null);
        return null;
      }

      descriptor.level = profile.level;
      descriptor.bottom = profile.bottom;
      lakeDescriptors.set(key, descriptor);
      return descriptor;
    }

    function getLakeAt(wx, wz) {
      const lx = Math.floor(wx / LAKE_CELL + 0.5);
      const lz = Math.floor(wz / LAKE_CELL + 0.5);
      const descriptor = getLakeDescriptor(lx, lz);
      if (!descriptor) return null;
      const dx = wx - descriptor.cx;
      const dz = wz - descriptor.cz;
      if (dx * dx + dz * dz >= descriptor.r * descriptor.r) return null;
      return descriptor;
    }

    function getLakeAtWater(wx, wz) {
      const lake = getLakeAt(wx, wz);
      if (!lake) return null;
      return isPointInsideLakeWater(lake, wx, wz) ? lake : null;
    }

    function getLakeBottomHeight(wx, wz) {
      const lake = getLakeAt(wx, wz);
      if (!lake) return getHeight(wx, wz);
      return getLakeBottomHeightForDescriptor(lake, wx, wz);
    }

    // Calculates the exact height of the terrain surface at any given world position,
    // accounting for the low-poly triangulation used in the chunk mesh.
    function getMeshHeight(wx, wz) {
      const cellX = Math.floor(wx / CELL);
      const cellZ = Math.floor(wz / CELL);

      const fx = (wx - cellX * CELL) / CELL;
      const fz = (wz - cellZ * CELL) / CELL;

      const h00 = getLakeBottomHeight(cellX * CELL, cellZ * CELL);
      const h10 = getLakeBottomHeight((cellX + 1) * CELL, cellZ * CELL);
      const h01 = getLakeBottomHeight(cellX * CELL, (cellZ + 1) * CELL);
      const h11 = getLakeBottomHeight((cellX + 1) * CELL, (cellZ + 1) * CELL);

      if (fx + fz <= 1) {
        return h00 + fx * (h10 - h00) + fz * (h01 - h00);
      } else {
        return h11 + (1 - fx) * (h01 - h11) + (1 - fz) * (h10 - h11);
      }
    }

    function getMeshAvgHeight(x, z, radius) {
      return Math.min(
        getMeshHeight(x, z), getMeshHeight(x + radius, z), getMeshHeight(x - radius, z),
        getMeshHeight(x, z + radius), getMeshHeight(x, z - radius)
      );
    }

    function chunkIntersectsLake(cx, cz, lake) {
      const ox = cx * CHUNK_SIZE;
      const oz = cz * CHUNK_SIZE;
      const minX = ox;
      const maxX = ox + CHUNK_SIZE;
      const minZ = oz;
      const maxZ = oz + CHUNK_SIZE;
      const waterRadius = getLakeWaterRadius(lake);

      if (lake.cx + waterRadius < minX) return false;
      if (lake.cx - waterRadius > maxX) return false;
      if (lake.cz + waterRadius < minZ) return false;
      if (lake.cz - waterRadius > maxZ) return false;
      return true;
    }

    function createLakeSurface(lake) {
      if (lakes.has(lake.key)) return;
      const half = getLakeWaterRadius(lake);
      const depth = Math.max(LAKE_MIN_VISIBLE_DEPTH, lake.depth * 1.35);
      const geo = new THREE.CylinderGeometry(half, half, depth, 32);
      const waterBody = new THREE.Mesh(geo, sharedBackdropWaterMaterial);
      // Keep the water top flat at the lake level, sink thickness downward.
      waterBody.position.set(lake.cx, lake.level - depth * 0.5, lake.cz);
      waterBody.castShadow = false;
      waterBody.receiveShadow = false;
      waterBody.renderOrder = 2;
      scene.add(waterBody);

      lakes.set(lake.key, { surface: waterBody, volume: null });
    }

    function disposeLakeSurface(lakeKey) {
      const water = lakes.get(lakeKey);
      if (!water) return;
      if (water.surface) {
        scene.remove(water.surface);
        water.surface.geometry.dispose();
      }
      if (water.volume) {
        scene.remove(water.volume);
        water.volume.geometry.dispose();
      }
      lakes.delete(lakeKey);
    }

    function syncVisibleLakes(neededChunkKeys) {
      const requiredLakes = new Set();

      for (const chunk of neededChunkKeys) {
        const [cx, cz] = chunk.split(',').map(Number);
        const ox = cx * CHUNK_SIZE;
        const oz = cz * CHUNK_SIZE;
        const margin = LAKE_MAX_RADIUS + 2;
        const lxMin = Math.floor((ox - margin) / LAKE_CELL) - 1;
        const lxMax = Math.floor((ox + CHUNK_SIZE + margin) / LAKE_CELL) + 1;
        const lzMin = Math.floor((oz - margin) / LAKE_CELL) - 1;
        const lzMax = Math.floor((oz + CHUNK_SIZE + margin) / LAKE_CELL) + 1;

        for (let lz = lzMin; lz <= lzMax; lz++) {
          for (let lx = lxMin; lx <= lxMax; lx++) {
            const lake = getLakeDescriptor(lx, lz);
            if (!lake) continue;
            if (!chunkIntersectsLake(cx, cz, lake)) continue;
            requiredLakes.add(lake.key);
            createLakeSurface(lake);
          }
        }
      }

      for (const lakeKey of lakes.keys()) {
        if (!requiredLakes.has(lakeKey)) disposeLakeSurface(lakeKey);
      }
    }

    // ============================================================
    // WATER FOAM SYSTEM - Realistic flat foam on water surface
    // ============================================================
    const splashEffects = []; // Temporary splash effects that fade out
    const waterlineFoams = new Map(); // Persistent foam for floating objects (object -> foam data)

    // Create flat foam texture directly on water surface
    function createFoamMesh(x, z, baseRadius, lake, isSplash = false) {
      const group = new THREE.Group();

      // Create flat foam patches using CircleGeometry lying flat on water
      const patchCount = isSplash ? 12 : 8;

      for (let i = 0; i < patchCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * baseRadius * 0.9;
        const patchRadius = 0.03 + Math.random() * 0.08;

        // Flat circle on water surface
        const geometry = new THREE.CircleGeometry(patchRadius, 8);
        const material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5 + Math.random() * 0.5,
          side: THREE.DoubleSide,
          depthWrite: false
        });

        const patch = new THREE.Mesh(geometry, material);
        patch.position.set(
          Math.cos(angle) * dist,
          0, // Exactly on water surface
          Math.sin(angle) * dist
        );
        // Rotate to lie flat on water (XZ plane)
        patch.rotation.x = -Math.PI / 2;
        patch.rotation.z = Math.random() * Math.PI;

        group.add(patch);
      }

      // Add larger irregular foam shapes
      const clumpCount = isSplash ? 6 : 4;
      for (let i = 0; i < clumpCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * baseRadius * 0.7;

        // Irregular shape using distorted circle
        const clumpRadius = 0.05 + Math.random() * 0.1;
        const geometry = new THREE.CircleGeometry(clumpRadius, 6);

        // Distort vertices for organic look
        const pos = geometry.attributes.position;
        for (let j = 0; j < pos.count; j++) {
          const px = pos.getX(j);
          const py = pos.getY(j);
          const distort = 0.7 + Math.random() * 0.6;
          pos.setX(j, px * distort);
          pos.setY(j, py * distort);
        }
        geometry.computeVertexNormals();

        const material = new THREE.MeshBasicMaterial({
          color: 0xf0f5ff, // Slightly blue-white
          transparent: true,
          opacity: 0.6 + Math.random() * 0.4,
          side: THREE.DoubleSide,
          depthWrite: false
        });

        const clump = new THREE.Mesh(geometry, material);
        clump.position.set(
          Math.cos(angle) * dist,
          0,
          Math.sin(angle) * dist
        );
        clump.rotation.x = -Math.PI / 2;
        clump.rotation.z = Math.random() * Math.PI * 2;

        group.add(clump);
      }

      // Position exactly at water level
      group.position.set(x, lake.level + 0.005, z); // Tiny offset to prevent z-fighting
      return group;
    }

    // Create splash effect with expanding foam ring
    function createSplash(x, z, radius, lake) {
      const foam = createFoamMesh(x, z, radius, lake, true);
      foam.userData = {
        born: performance.now(),
        duration: 2000,
        lake,
        baseRadius: radius
      };
      scene.add(foam);
      splashEffects.push(foam);
    }

    // Create waterline foam - foam ring around floating object
    function createWaterlineFoam(obj, objPos, objRadius, lake) {
      const foam = createFoamMesh(objPos.x, objPos.z, objRadius * 0.4, lake, false);
      foam.userData = { obj, lake, radius: objRadius };
      scene.add(foam);
      return foam;
    }

    // Track objects that just entered water (for splash)
    const waterEntryTracker = new Map(); // object id -> { wasInWater, entryTime }

    // Helper to dispose a foam group (with children)
    function disposeFoamGroup(foam) {
      for (const child of foam.children) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      }
      scene.remove(foam);
    }

    function updateFoamSystem(dt) {
      const now = performance.now();

      // Update and remove expired splash effects
      for (let i = splashEffects.length - 1; i >= 0; i--) {
        const splash = splashEffects[i];
        const age = now - splash.userData.born;
        const progress = age / splash.userData.duration;

        if (progress >= 1) {
          disposeFoamGroup(splash);
          splashEffects.splice(i, 1);
        } else {
          // Fade out all children and expand the group
          const opacity = 0.8 * (1 - progress);
          for (const child of splash.children) {
            if (child.material) {
              child.material.opacity = opacity * (0.6 + Math.random() * 0.4);
            }
          }
          splash.scale.setScalar(1 + progress * 2);
        }
      }

      // Process projectiles for splash and waterline foam
      for (const p of projectiles) {
        const t = p.body.translation();
        const lake = getLakeAtWater(t.x, t.z);
        const objId = p.mesh.uuid;
        const isInWater = lake && t.y < lake.level;
        const wasTracked = waterEntryTracker.get(objId);

        if (isInWater) {
          if (!wasTracked || !wasTracked.wasInWater) {
            // Just entered water - create splash
            createSplash(t.x, t.z, 0.5, lake);
            waterEntryTracker.set(objId, { wasInWater: true, entryTime: now, lake });
          }

          // Check if floating (partially above water)
          const objRadius = p.mesh.geometry?.boundingSphere?.radius || 0.25;
          const isFloating = t.y + objRadius > lake.level && t.y - objRadius < lake.level;

          if (isFloating) {
            // Update or create waterline foam
            if (!waterlineFoams.has(objId)) {
              const foam = createWaterlineFoam(p, t, objRadius, lake);
              waterlineFoams.set(objId, { foam, obj: p, lake });
            } else {
              const foamData = waterlineFoams.get(objId);
              foamData.foam.position.set(t.x, lake.level + 0.02, t.z);
            }
          } else {
            // Fully submerged - remove waterline foam
            if (waterlineFoams.has(objId)) {
              const foamData = waterlineFoams.get(objId);
              disposeFoamGroup(foamData.foam);
              waterlineFoams.delete(objId);
            }
          }
        } else {
          // Not in water - clean up
          if (waterlineFoams.has(objId)) {
            const foamData = waterlineFoams.get(objId);
            disposeFoamGroup(foamData.foam);
            waterlineFoams.delete(objId);
          }
          waterEntryTracker.set(objId, { wasInWater: false, entryTime: null });
        }
      }

      // Process rigid bodies for splash and waterline foam
      for (const rb of rigidBodies) {
        if (rb.body.isFixed()) continue;
        const t = rb.body.translation();
        const lake = getLakeAtWater(t.x, t.z);
        const objId = rb.mesh.uuid;
        const isInWater = lake && t.y < lake.level;
        const wasTracked = waterEntryTracker.get(objId);

        if (isInWater) {
          if (!wasTracked || !wasTracked.wasInWater) {
            // Just entered water - create splash
            createSplash(t.x, t.z, 0.8, lake);
            waterEntryTracker.set(objId, { wasInWater: true, entryTime: now, lake });
          }

          // Check if floating (partially above water)
          const objRadius = rb.mesh.geometry?.boundingSphere?.radius || 0.6;
          const isFloating = t.y + objRadius > lake.level && t.y - objRadius < lake.level;

          if (isFloating) {
            // Update or create waterline foam
            if (!waterlineFoams.has(objId)) {
              const foam = createWaterlineFoam(rb, t, objRadius, lake);
              waterlineFoams.set(objId, { foam, obj: rb, lake });
            } else {
              const foamData = waterlineFoams.get(objId);
              foamData.foam.position.set(t.x, lake.level + 0.02, t.z);
            }
          } else {
            // Fully submerged - remove waterline foam
            if (waterlineFoams.has(objId)) {
              const foamData = waterlineFoams.get(objId);
              disposeFoamGroup(foamData.foam);
              waterlineFoams.delete(objId);
            }
          }
        } else {
          // Not in water - clean up
          if (waterlineFoams.has(objId)) {
            const foamData = waterlineFoams.get(objId);
            disposeFoamGroup(foamData.foam);
            waterlineFoams.delete(objId);
          }
          waterEntryTracker.set(objId, { wasInWater: false, entryTime: null });
        }
      }
    }

    // ============================================================
    // DANCING BALLS IN STARTING LAKE (from lake_scene files)
    // ============================================================
    const dancingBalls = [];
    const dancingBallsBodies = []; // Physics bodies for the balls
    let dancingBallsPlatform = null;
    let dancingBallsPlatformBody = null; // Physics body for platform
    let dancingBallsModel = null;
    let dancingBallsMixer = null;
    let startingLake = null;
    let iceColorNode = null;

    function createDancingBalls() {
      // Find the lake at or near the starting position (0,0)
      startingLake = getLakeAt(0, 0);
      if (!startingLake) {
        const lx = Math.floor(0 / LAKE_CELL + 0.5);
        const lz = Math.floor(0 / LAKE_CELL + 0.5);
        startingLake = getLakeDescriptor(lx, lz);
      }

      if (!startingLake) {
        console.log('No starting lake found for dancing balls');
        return;
      }

      console.log('Creating dancing balls in lake at:', startingLake.cx, startingLake.cz, 'level:', startingLake.level);

      // Load texture for the ice balls (from lake_scene files)
      const textureLoader = new THREE.TextureLoader();
      const iceDiffuse = textureLoader.load('water.jpg');
      iceDiffuse.wrapS = THREE.RepeatWrapping;
      iceDiffuse.wrapT = THREE.RepeatWrapping;
      iceDiffuse.colorSpace = THREE.NoColorSpace;

      // Create the ice color node using triplanar texture (from lake_scene files)
      iceColorNode = triplanarTexture(texture(iceDiffuse)).add(color(0x0066ff)).mul(0.8);

      // Create floating icosahedron balls (from lake_scene 15 & 17)
      const iceGeometry = new THREE.IcosahedronGeometry(1, 3);
      const iceMaterial = new THREE.MeshStandardNodeMaterial({ colorNode: iceColorNode });

      const count = 100;
      const scale = 3.5;
      const column = 10;

      const objectsGroup = new THREE.Group();
      for (let i = 0; i < count; i++) {
        const x = i % column;
        const y = Math.floor(i / column);
        const mesh = new THREE.Mesh(iceGeometry, iceMaterial);
        mesh.position.set(x * scale, 0, y * scale);
        mesh.rotation.set(Math.random(), Math.random(), Math.random());
        mesh.castShadow = true;
        objectsGroup.add(mesh);
      }

      // Position the group centered over the lake
      objectsGroup.position.set(
        startingLake.cx - ((column - 1) * scale) * 0.5,
        startingLake.level - 1,
        startingLake.cz - ((count / column) * scale) * 0.5
      );
      scene.add(objectsGroup);
      dancingBalls.push(...objectsGroup.children);

      // Create the cylindrical platform (from lake_scene 17)
      const platformGeo = new THREE.CylinderGeometry(1.1, 1.1, 10);
      const platformMat = new THREE.MeshStandardNodeMaterial({ colorNode: iceColorNode });
      dancingBallsPlatform = new THREE.Mesh(platformGeo, platformMat);
      dancingBallsPlatform.position.set(startingLake.cx, startingLake.level - 5, startingLake.cz);
      dancingBallsPlatform.castShadow = true;
      dancingBallsPlatform.receiveShadow = true;
      scene.add(dancingBallsPlatform);

      // Load the dancing character model (Michelle from lake_scene 17)
      const gltfLoader = new GLTFLoader();
      gltfLoader.load(
        'https://threejs.org/examples/models/gltf/Michelle.glb',
        (gltf) => {
          dancingBallsModel = gltf.scene;
          dancingBallsMixer = new THREE.AnimationMixer(dancingBallsModel);
          const action = dancingBallsMixer.clipAction(gltf.animations[0]);
          action.play();
          dancingBallsModel.position.set(startingLake.cx, startingLake.level, startingLake.cz);
          dancingBallsModel.scale.set(1, 1, 1);
          scene.add(dancingBallsModel);
          console.log('Dancing model loaded');

          // Add physics to the dancer model after it loads
          addDancerPhysics();
        },
        undefined,
        () => {
          console.log('Could not load dancing model');
        }
      );

      console.log('Created', dancingBalls.length, 'floating ice balls');
    }

    // Add physics to dancing balls after Rapier is loaded
    function addDancingBallsPhysics() {
      if (!RAPIER || !physWorld || !startingLake) return;

      // Add physics to each ball
      for (const ball of dancingBalls) {
        const worldPos = new THREE.Vector3();
        ball.getWorldPosition(worldPos);

        const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
          .setTranslation(worldPos.x, worldPos.y, worldPos.z);
        const body = physWorld.createRigidBody(bodyDesc);

        const colDesc = RAPIER.ColliderDesc.ball(1.0) // radius 1 for icosahedron
          .setRestitution(0.6)
          .setFriction(0.3)
          .setDensity(0.5);
        physWorld.createCollider(colDesc, body);

        dancingBallsBodies.push({ mesh: ball, body });
      }

      // Add physics to platform (static)
      if (dancingBallsPlatform) {
        const platformPos = dancingBallsPlatform.position;
        const bodyDesc = RAPIER.RigidBodyDesc.fixed()
          .setTranslation(platformPos.x, platformPos.y, platformPos.z);
        dancingBallsPlatformBody = physWorld.createRigidBody(bodyDesc);

        const colDesc = RAPIER.ColliderDesc.cylinder(5, 1.1) // half-height 5, radius 1.1
          .setRestitution(0.3)
          .setFriction(0.8);
        physWorld.createCollider(colDesc, dancingBallsPlatformBody);
        console.log('Added physics to dancing balls platform');
      }

      console.log('Added physics to', dancingBallsBodies.length, 'dancing balls');
    }

    function animateDancingBalls(time, dt) {
      // Animate the dancing model
      if (dancingBallsMixer && dancingBallsModel) {
        dancingBallsMixer.update(dt);
      }

      // Animate the floating icosahedron balls (original animation from lake_scene)
      for (const object of dancingBalls) {
        object.position.y = Math.sin(time + object.id) * 0.3;
        object.rotation.y += dt * 0.3;
      }

      // Sync physics bodies with animated positions and apply water physics
      for (let i = 0; i < dancingBallsBodies.length; i++) {
        const { mesh, body } = dancingBallsBodies[i];
        const worldPos = new THREE.Vector3();
        mesh.getWorldPosition(worldPos);

        // Sync body position with animated mesh position
        if (typeof body.setTranslation === 'function') {
          body.setTranslation({ x: worldPos.x, y: worldPos.y, z: worldPos.z }, false);
        }

        // Apply water physics if ball is in water
        if (startingLake && worldPos.y < startingLake.level) {
          const vel = body.linvel();
          const waterDrag = 0.92;
          const buoyancy = 2.0;

          body.setLinvel({
            x: vel.x * waterDrag,
            y: vel.y * waterDrag + buoyancy * dt,
            z: vel.z * waterDrag
          }, false);
        }
      }
    }

    // ============================================================
    // STARFIELD (NIGHT SKY)
    // ============================================================
    const starsGeo = new THREE.BufferGeometry();
    const starsCount = 1500;
    const starsPos = new Float32Array(starsCount * 3);
    let starIdx = 0;
    while (starIdx < starsCount) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random() * 2) - 1);
      // Strictly restrict to upper hemisphere (y > 0) to avoid stars on ground
      if (phi >= Math.PI / 2) continue;

      const r = 500 + Math.random() * 100;
      starsPos[starIdx * 3] = r * Math.sin(phi) * Math.cos(theta);
      starsPos[starIdx * 3 + 1] = r * Math.cos(phi);
      starsPos[starIdx * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      starIdx++;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
    const starsMat = new THREE.PointsMaterial({
      color: 0xffffff, size: 2.0, transparent: true, opacity: 0.0, fog: false, depthWrite: false, depthTest: true
    });
    const starsSystem = new THREE.Points(starsGeo, starsMat);
    scene.add(starsSystem);

    // ============================================================
    // WEATHER SYSTEM
    // ============================================================
    let currentWeatherType = 'Clear'; // 'Clear', 'Snow', 'Rain', 'Wind'

    const weatherGeo = new THREE.BufferGeometry();
    const weatherCount = 2000;
    const weatherPositions = new Float32Array(weatherCount * 3);
    const weatherVelocities = new Float32Array(weatherCount * 3);

    for (let i = 0; i < weatherCount; i++) {
      // Spawn particles in a volume around the player
      weatherPositions[i * 3] = (Math.random() - 0.5) * 150;
      weatherPositions[i * 3 + 1] = 10 + Math.random() * 90;
      weatherPositions[i * 3 + 2] = (Math.random() - 0.5) * 150;
      weatherVelocities[i * 3] = 0;
      weatherVelocities[i * 3 + 1] = 0;
      weatherVelocities[i * 3 + 2] = 0;
    }

    weatherGeo.setAttribute('position', new THREE.BufferAttribute(weatherPositions, 3));

    const weatherMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.6,
      transparent: true,
      opacity: 0.0,
      depthWrite: false,
      depthTest: true, // Prevents particles from rendering in front of mountains
      blending: THREE.NormalBlending
    });

    const weatherSystem = new THREE.Points(weatherGeo, weatherMat);
    scene.add(weatherSystem);

    function setRandomWeatherForSeason() {
      const rand = Math.random();
      if (currentSeason === 'Winter') {
        currentWeatherType = rand > 0.4 ? 'Snow' : 'Clear';
      } else if (currentSeason === 'Autumn') {
        currentWeatherType = rand > 0.4 ? (rand > 0.7 ? 'Rain' : 'Wind') : 'Clear';
      } else if (currentSeason === 'Spring') {
        currentWeatherType = rand > 0.4 ? (rand > 0.7 ? 'Rain' : 'Wind') : 'Clear';
      } else {
        currentWeatherType = rand > 0.8 ? 'Rain' : 'Clear'; // Summer is usually clear
      }

      if (currentWeatherType === 'Clear') {
        weatherMat.opacity = 0.0;
      } else if (currentWeatherType === 'Snow') {
        weatherMat.opacity = 0.7;
        weatherMat.color.setHex(0xffffff);
        weatherMat.size = 0.8;
      } else if (currentWeatherType === 'Rain') {
        weatherMat.opacity = 0.4;
        weatherMat.color.setHex(0xaaaaaa);
        weatherMat.size = 0.3;
      } else if (currentWeatherType === 'Wind') {
        weatherMat.opacity = 0.9;
        weatherMat.color.setHex(currentSeason === 'Autumn' ? 0xd35400 : 0xffb6c1);
        weatherMat.size = 0.6;
      }

      for (let i = 0; i < weatherCount; i++) {
        if (currentWeatherType === 'Snow') {
          weatherVelocities[i * 3] = (Math.random() - 0.5) * 2;
          weatherVelocities[i * 3 + 1] = -3 - Math.random() * 3;
          weatherVelocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
        } else if (currentWeatherType === 'Rain') {
          weatherVelocities[i * 3] = (Math.random() - 0.5);
          weatherVelocities[i * 3 + 1] = -15 - Math.random() * 10;
          weatherVelocities[i * 3 + 2] = (Math.random() - 0.5);
        } else if (currentWeatherType === 'Wind') {
          weatherVelocities[i * 3] = 6 + Math.random() * 4;
          weatherVelocities[i * 3 + 1] = -1 - Math.random() * 2;
          weatherVelocities[i * 3 + 2] = 2 + Math.random() * 3;
        }
      }
    }

    // Call immediately to set initial weather
    setRandomWeatherForSeason();

    function updateWeather(dt) {
      if (weatherMat.opacity <= 0) return;

      weatherSystem.position.x = camera.position.x;
      weatherSystem.position.z = camera.position.z;

      const pos = weatherGeo.attributes.position.array;
      const t = performance.now() / 1000;
      for (let i = 0; i < weatherCount; i++) {
        let vx = weatherVelocities[i * 3];
        let vy = weatherVelocities[i * 3 + 1];
        let vz = weatherVelocities[i * 3 + 2];

        if (currentWeatherType === 'Snow') {
          vx += Math.sin(t * 2 + i) * 0.1;
          vz += Math.cos(t * 2 + i) * 0.1;
        } else if (currentWeatherType === 'Wind') {
          vy += Math.cos(t * 1 + i) * 0.05;
        }

        pos[i * 3] += vx * dt;
        pos[i * 3 + 1] += vy * dt;
        pos[i * 3 + 2] += vz * dt;

        if (pos[i * 3 + 1] < -10 || (currentWeatherType === 'Wind' && pos[i * 3] > 75)) {
          pos[i * 3 + 1] = 80 + Math.random() * 20;
          pos[i * 3] = (Math.random() - 0.5) * 150;
          if (currentWeatherType === 'Wind') pos[i * 3] = -75; // spawn upwind
          pos[i * 3 + 2] = (Math.random() - 0.5) * 150;
        }
      }
      weatherGeo.attributes.position.needsUpdate = true;
    }

    // ============================================================
    // BIRDS
    // ============================================================
    const birds = [];
    for (let i = 0; i < 25; i++) {
      const b = new THREE.Group();
      // simple V-shape wings
      const wL = jitter(new THREE.ConeGeometry(0.25, 0.6, 3), 0.05);
      const wR = jitter(new THREE.ConeGeometry(0.25, 0.6, 3), 0.05);
      const mL = new THREE.Mesh(wL, matBird);
      const mR = new THREE.Mesh(wR, matBird);
      mL.rotation.z = Math.PI / 2;
      mR.rotation.z = -Math.PI / 2;
      mL.position.x = -0.3;
      mR.position.x = 0.3;
      b.add(mL); b.add(mR);
      const angle = Math.random() * Math.PI * 2;
      const rad = 40 + Math.random() * 80;
      b.position.set(Math.cos(angle) * rad, 20 + Math.random() * 30, Math.sin(angle) * rad);
      b.userData = {
        angle, rad,
        speed: 0.003 + Math.random() * 0.004,
        height: 20 + Math.random() * 30,
        flapSpeed: 3 + Math.random() * 3,
        flapAmp: 0.4 + Math.random() * 0.3,
        t: Math.random() * 100
      };
      scene.add(b);
      birds.push(b);
    }

    // ============================================================
    // CHUNK SYSTEM
    // ============================================================
    const chunks = new Map();
    const objects = new Map(); // decorations per chunk

    function chunkKey(cx, cz) { return `${cx},${cz}`; }

    function buildChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      if (chunks.has(key)) return;

      const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;
      const N = CHUNK_SEGS;
      const verts = [], colors = [], indices = [];

      // Build height grid
      const heights = [];
      for (let z = 0; z <= N; z++) for (let x = 0; x <= N; x++) {
        const wx = ox + x * CELL, wz = oz + z * CELL;
        const h = getLakeBottomHeight(wx, wz);
        heights.push(h);
      }

      // Build geometry
      for (let z = 0; z <= N; z++) for (let x = 0; x <= N; x++) {
        const wx = ox + x * CELL, wz = oz + z * CELL;
        const h = heights[z * (N + 1) + x];
        verts.push(x * CELL, h, z * CELL);
        // color
        const lake = isLake(wx, wz);
        const path = !lake && isPath(wx, wz);
        let r, g, b;
        if (lake) {
          // Check if this is lake floor (flat bottom) or lake wall (sloped sides)
          // Lake floor = height is close to the bottom of the lake
          // Lake wall = height is significantly higher than the bottom
          const lakeDesc = getLakeAt(wx, wz);
          const isLakeFloor = lakeDesc && (h < lakeDesc.bottom + 2.0); // Within 2 units of lake bottom

          if (isLakeFloor) {
            // Lake floor - deep dark blue like deep ocean water (0x0A1628 - Deep Navy)
            r = 0.039; g = 0.086; b = 0.157;
          } else {
            // Lake walls - sandy/earthy color like the rest of the terrain
            r = 0.6; g = 0.45; b = 0.3;
          }
        }
        else if (path) {
          if (currentSeason === 'Winter') { r = 0.8; g = 0.85; b = 0.9; }
          else { r = 0.68; g = 0.52; b = 0.28; }
        }
        else if (h < 1.5) {
          if (currentSeason === 'Winter') { r = 0.8; g = 0.85; b = 0.9; }
          else { r = 0.6; g = 0.45; b = 0.3; } // sandy
        }
        else { // grass variation
          const gv = 0.32 + fbm(wx * 0.04, wz * 0.04) * 0.15;
          if (currentSeason === 'Winter') {
            r = 0.8 + gv * 0.2; g = 0.85 + gv * 0.15; b = 0.9 + gv * 0.1;
          } else if (currentSeason === 'Autumn') {
            r = gv * 1.5; g = gv * 1.2; b = gv * 0.6;
          } else if (currentSeason === 'Spring') {
            r = gv * 1.1; g = gv * 2.1; b = gv * 0.9;
          } else {
            // Summer
            r = gv; g = gv * 1.8; b = gv * 0.8;
          }
        }

        // Apply global desaturation or brightness adjusting per season
        if (currentSeason === 'Winter' && !lake) {
          r = Math.min(1.0, r * 1.1); g = Math.min(1.0, g * 1.1); b = Math.min(1.0, b * 1.1);
        }

        colors.push(r, g, b);
      }
      for (let z = 0; z < N; z++) for (let x = 0; x < N; x++) {
        const a = z * (N + 1) + x, b = a + 1, c = a + (N + 1), d = c + 1;
        indices.push(a, c, b, b, c, d);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geo.setIndex(indices);
      geo.computeVertexNormals();

      const mat = new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(ox, 0, oz);
      mesh.receiveShadow = true;
      mesh.castShadow = false;
      scene.add(mesh);
      chunks.set(key, mesh);

      // --- Physics collider for this terrain chunk (static trimesh) ---
      // IMPORTANT: Build vertices in CHUNK-LOCAL coordinates (same as the Three.js geometry),
      // and place the collider using translation (ox, oz). This keeps physics aligned with visuals.
      if (physWorld && RAPIER) {
        const posAttr = geo.getAttribute('position');
        const idxAttr = geo.index;

        // Positions in chunk-local space
        const verts = new Float32Array(posAttr.count * 3);
        for (let i = 0; i < posAttr.count; i++) {
          verts[i * 3 + 0] = posAttr.getX(i);
          verts[i * 3 + 1] = posAttr.getY(i);
          verts[i * 3 + 2] = posAttr.getZ(i);
        }

        // Indices
        let indices;
        if (idxAttr) {
          indices = new Uint32Array(idxAttr.count);
          for (let i = 0; i < idxAttr.count; i++) indices[i] = idxAttr.getX(i);
        } else {
          indices = new Uint32Array(posAttr.count);
          for (let i = 0; i < posAttr.count; i++) indices[i] = i;
        }

        // Create collider directly (fixed body not needed)
        // trimesh expects vertices as Float32Array and indices as Uint32Array
        const colDesc = RAPIER.ColliderDesc.trimesh(verts, indices)
          .setTranslation(ox, 0, oz)
          .setRestitution(0.0)
          .setFriction(0.9);

        const collider = physWorld.createCollider(colDesc);
        terrainColliders.set(key, collider);
      }

      // Decorations - use world coords directly, no group offset
      const group = new THREE.Group();
      scene.add(group);
      const rng = (s) => { let v = hash(cx * 17 + s, cz * 31 + s * 7); return v; };

      const decCount = HIGH_QUALITY
        ? 30 + Math.floor(rng(1) * 20)
        : 18 + Math.floor(rng(1) * 10);
      for (let i = 0; i < decCount; i++) {
        // World-space position of this decoration
        const tx = ox + rng(i * 7 + 2) * CHUNK_SIZE;
        const tz = oz + rng(i * 7 + 3) * CHUNK_SIZE;
        if (isLake(tx, tz) || isPath(tx, tz)) continue;
        const h = getMeshHeight(tx, tz);   // exact height at this world pos
        if (h < 1) continue;
        const r4 = rng(i * 7 + 4);
        let obj;
        // Seeded rng for this specific object - deterministic every rebuild
        const objRng = (k) => hash(cx * 113 + i * 71 + k * 37, cz * 97 + i * 53 + k * 19);
        if (r4 < 0.25) {
          // Standard Stylized angular tree
          obj = makeTree(tx, h, tz, 0.7 + rng(i * 7 + 5) * 0.8, 0, objRng);
        } else if (r4 < 0.40) {
          // Pine Tree
          obj = makeTree(tx, h, tz, 0.9 + rng(i * 7 + 5) * 1.0, 1, objRng);
        } else if (r4 < 0.55) {
          // Round Tree
          obj = makeTree(tx, h, tz, 0.6 + rng(i * 7 + 5) * 0.6, 2, objRng);
        } else if (r4 < 0.65) {
          obj = makeRock(tx, h, tz, objRng);
        } else if (r4 < 0.85) {
          obj = makeBush(tx, h, tz, objRng);
        } else if (r4 < 0.95) {
          obj = makeFlower(tx, h, tz, objRng);
        }
        if (obj) group.add(obj);
      }

      // No position offset - objects are in world space already
      objects.set(key, group);

      // Create physics colliders for decorations in this chunk
      if (physWorld && RAPIER) addDecorationCollidersFromGroup(group);
    }

    function removeChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      const mesh = chunks.get(key);
      if (mesh) { scene.remove(mesh); mesh.geometry.dispose(); chunks.delete(key); }
      const grp = objects.get(key);
      if (grp) { scene.remove(grp); objects.delete(key); }

      // Remove physics collider for this chunk
      if (physWorld && terrainColliders.has(key)) {
        physWorld.removeCollider(terrainColliders.get(key), true);
        terrainColliders.delete(key);
      }

      // Remove & rebuild decoration colliders lazily (next frame) to avoid stutter in the middle of movement.
      if (physWorld && RAPIER) decorationsDirty = true;
    }

    function updateChunks(px, pz) {
      // Use floor so we don't thrash chunk rebuilds around boundaries.
      // Rounding can cause rapid add/remove when hovering near edges -> stutter.
      const curCX = Math.floor(px / CHUNK_SIZE);
      const curCZ = Math.floor(pz / CHUNK_SIZE);
      const needed = new Set();
      const R = RENDER_CHUNKS;
      for (let dz = -R; dz <= R; dz++) for (let dx = -R; dx <= R; dx++) {
        if (dx * dx + dz * dz > R * R + 1) continue;
        const cx = curCX + dx, cz = curCZ + dz;
        needed.add(chunkKey(cx, cz));
        buildChunk(cx, cz);
      }
      for (const [key] of chunks) {
        if (!needed.has(key)) removeChunk(...key.split(',').map(Number));
      }
      syncVisibleLakes(needed);
    }

    // ============================================================
    // INPUT & POINTER LOCK
    // ============================================================
    const keys = {};
    let yaw = 0, pitch = 0;
    let started = false;
    let flyMode = false;
    let isLocked = false;

    renderer.domElement.style.cursor = 'crosshair';
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Click canvas = lock pointer (true FPS)
    renderer.domElement.addEventListener('click', () => {
      if (!started) return;
      renderer.domElement.requestPointerLock();
    });

    document.getElementById('click-to-start').addEventListener('click', () => {
      started = true;
      document.getElementById('click-to-start').style.display = 'none';
      renderer.domElement.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
      isLocked = document.pointerLockElement === renderer.domElement;
    });
    document.addEventListener('pointerlockerror', () => {
      console.warn('Pointer lock failed');
    });

    document.addEventListener('mousemove', e => {
      if (!isLocked) return;
      yaw -= e.movementX * 0.002;
      pitch -= e.movementY * 0.002;
      pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, pitch));
    });

    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.code === 'KeyF') { flyMode = !flyMode; }
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.code] = false; });

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ============================================================
    // HELPERS
    // ============================================================
    function getTerrainY(x, z) {
      return getLakeBottomHeight(x, z);
    }
    function getAvgHeight(x, z, radius) {
      return Math.min(
        getHeight(x, z), getHeight(x + radius, z), getHeight(x - radius, z),
        getHeight(x, z + radius), getHeight(x, z - radius)
      );
    }



    // ============================================================
    // PHYSICS CONSTANTS
    // ============================================================
    const SPEED = 9;
    const RUN_SPEED = 20;
    const FLY_SPEED = 16;
    const JUMP_VEL = 8;
    const GRAVITY_ACC = -22;
    const EYE_HEIGHT = 1.75;

    // Player physics capsule (Rapier)
    const PLAYER_RADIUS = 0.35;
    const PLAYER_HALF_HEIGHT = 0.55; // half of cylinder part (excluding hemispheres)
    const PLAYER_MASS = 70;

    let velY = 0; // legacy fallback when Rapier not ready
    let isGrounded = false;
    const playerPos = new THREE.Vector3(0, 10, 0);

    // Rapier player body/collider
    let playerBody = null;
    let playerCollider = null;
    let lastJumpTime = 0;

    // Robust terrain sampler - samples a small grid and returns max
    // to handle slopes: we want the HIGHEST point under the player's feet
    function sampleGround(x, z) {
      const r = 0.3; // player foot radius
      return Math.max(
        getTerrainY(x, z),
        getTerrainY(x + r, z),
        getTerrainY(x - r, z),
        getTerrainY(x, z + r),
        getTerrainY(x, z - r)
      );
    }

    let underwaterActive = false;
    function updateWaterViewState() {
      const lake = getLakeAtWater(playerPos.x, playerPos.z);
      const isUnderwater = !!lake && playerPos.y < lake.level - 0.03;
      if (isUnderwater === underwaterActive) return;

      underwaterActive = isUnderwater;
      if (underwaterActive) {
        scene.background = UNDERWATER_BG_COLOR.clone();
        scene.fog.color.copy(UNDERWATER_FOG_COLOR);
        scene.fog.near = UNDERWATER_FOG_NEAR;
        scene.fog.far = UNDERWATER_FOG_FAR;
        renderer.toneMappingExposure = TONE_EXPOSURE * 0.9;
        if (underwaterOverlay) underwaterOverlay.style.opacity = '1';
      } else {
        scene.background = SKY_BG_COLOR.clone();
        scene.fog.color.copy(SKY_FOG_COLOR);
        scene.fog.near = SKY_FOG_NEAR;
        scene.fog.far = SKY_FOG_FAR;
        renderer.toneMappingExposure = TONE_EXPOSURE;
        if (underwaterOverlay) underwaterOverlay.style.opacity = '0';
      }
    }

    // ============================================================
    // ANIMATION LOOP
    // ============================================================
    let last = performance.now();
    let renderFailureShown = false;
    let renderInFlight = false;

    function reportRenderFailure(err) {
      if (renderFailureShown) return;
      showWebGPUError('×©×’×™××ª ×¨×™× ×“×•×¨ WebGPU. ×‘×“×•×§ ×ª××™×›×” ×‘×“×¤×“×¤×Ÿ/×“×¨×™×™×‘×¨.');
      console.error('WebGPU render failed:', err);
      renderFailureShown = true;
    }

    function renderFrame() {
      if (typeof renderer.renderAsync === 'function') {
        if (renderInFlight) return;
        renderInFlight = true;
        renderer.renderAsync(scene, camera)
          .catch(reportRenderFailure)
          .finally(() => { renderInFlight = false; });
        return;
      }
      if (typeof renderer.render === 'function') {
        // Update weather
        updateWeather(dt);

        // Render
        renderer.render(scene, camera);
        try {
          renderer.render(scene, camera);
        } catch (err) {
          reportRenderFailure(err);
        }
        return;
      }
      reportRenderFailure(new TypeError('Renderer does not expose render/renderAsync'));
    }

    // Set up season and time/date UI
    const timeSlider = document.getElementById('time-slider');
    const daySlider = document.getElementById('day-slider');
    const timeDisplay = document.getElementById('time-display');
    const dayDisplay = document.getElementById('day-display');

    timeSlider.addEventListener('input', (e) => {
      currentTimeOfDay = parseFloat(e.target.value);
      const hrs = Math.floor(currentTimeOfDay).toString().padStart(2, '0');
      const mins = Math.floor((currentTimeOfDay % 1) * 60).toString().padStart(2, '0');
      timeDisplay.textContent = `${hrs}:${mins}`;
      updateLighting();
    });

    daySlider.addEventListener('input', (e) => {
      currentDayOfMonth = parseInt(e.target.value);
      dayDisplay.textContent = currentDayOfMonth.toString();
      updateLighting();
    });

    document.querySelectorAll('.season-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.season-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        const newSeason = e.target.getAttribute('data-season');
        if (newSeason !== currentSeason) {
          currentSeason = newSeason;
          updateLighting();
          rebuildWorldForSeason();
        }
      });
    });

    function updateLighting() {
      // 0 = midnight, 6 = sunrise, 12 = noon, 18 = sunset, 24 = midnight
      const timeAngle = (currentTimeOfDay / 24) * Math.PI * 2 - Math.PI / 2;

      // Sun position logic
      const distance = 500;
      sunMesh.position.set(
        Math.cos(timeAngle) * distance,
        Math.sin(timeAngle) * distance,
        Math.sin(timeAngle * 0.5) * distance
      );
      sunGlow.position.copy(sunMesh.position);
      sun.position.copy(sunMesh.position);

      // Moon position: depends on both time of day and day of month
      // Day 15 (Full Moon): Opposite to sun (offset by PI)
      // Day 1 (New Moon): Roughly aligned with sun (offset by 0)
      const dayOffset = (currentDayOfMonth / 30) * Math.PI * 2;
      const moonAngle = timeAngle + dayOffset;

      moonMesh.position.set(
        Math.cos(moonAngle) * distance,
        Math.sin(moonAngle) * distance,
        -Math.sin(timeAngle * 0.5) * distance // offset z to avoid intersecting sun exactly
      );
      moonGlow.position.copy(moonMesh.position);
      moonLight.position.copy(moonMesh.position);

      // Night/Day intensity fading
      const elevation = Math.sin(timeAngle);
      const isDay = elevation > 0;

      if (isDay) {
        const sunStrength = Math.min(elevation * 3, 1.0);
        sun.intensity = SUN_INTENSITY * sunStrength;
        moonLight.intensity = 0;
        ambient.intensity = 0.5 * sunStrength + 0.1; // Baseline night ambient is 0.1
        hemi.intensity = HEMI_INTENSITY * sunStrength;
      } else {
        sun.intensity = 0;
        const moonElevation = Math.sin(moonAngle);
        const moonStrength = Math.max(0, Math.min(moonElevation * 2, 1.0));
        // Full moon = brightest. New moon = dimmest night.
        const phaseBrightness = 1.0 - Math.abs(currentDayOfMonth - 15) / 15.0; // 0 to 1 peak at 15

        moonLight.intensity = (0.5 + phaseBrightness * 0.8) * moonStrength;
        ambient.intensity = 0.1 + phaseBrightness * 0.15;
        hemi.intensity = 0.1;
      }

      // Hide/Show meshes below horizon
      sunMesh.visible = sunGlow.visible = (sunMesh.position.y > -50);
      moonMesh.visible = moonGlow.visible = (moonMesh.position.y > -50);

      // Star fading at night
      starsMat.opacity = isDay ? 0 : Math.min(1.0, -elevation * 2.0);
      starsSystem.position.copy(camera.position);

      // Update sky immediately
      let baseBgColor = SKY_BG_COLOR.clone();
      let baseFogColor = SKY_FOG_COLOR.clone();

      if (currentSeason === 'Winter') {
        baseBgColor.setHex(0x90a4ae);
        baseFogColor.setHex(0xcfdfeb);
      } else if (currentSeason === 'Autumn') {
        baseBgColor.lerp(new THREE.Color(0xffb347), 0.3);
        baseFogColor.lerp(new THREE.Color(0xffe0b2), 0.4);
      }

      // Blend to night sky
      const nightBgColor = new THREE.Color(0x0a0f1a);
      const nightFogColor = new THREE.Color(0x101828);

      // Calculate blend factor (1 = day, 0 = night)
      let blendFactor = THREE.MathUtils.clamp((elevation + 0.1) * 2, 0, 1);

      scene.background.copy(nightBgColor).lerp(baseBgColor, blendFactor);
      scene.fog.color.copy(nightFogColor).lerp(baseFogColor, blendFactor);
    }

    function rebuildWorldForSeason() {
      // Re-evaluate terrain and decoration colors
      // We must clear the chunks and objects maps, then force a rebuild of the visible ones
      for (const [key, mesh] of chunks) scene.remove(mesh);
      for (const [key, group] of objects) scene.remove(group);
      chunks.clear();
      objects.clear();

      // Update materials
      if (currentSeason === 'Winter') {
        matGrass.color.setHex(0xeef6f9);
        matDarkGrass.color.setHex(0xd0e8f2);
        matLeaf1.color.setHex(0xf5feff); // snow covered
        matLeaf2.color.setHex(0xe0f7fa);
        matLeaf3.color.setHex(0xb2ebf2);
        matDirt.color.setHex(0xe3ebf0); // snowy dirt
      } else if (currentSeason === 'Autumn') {
        matGrass.color.setHex(0x9a7b4f);
        matDarkGrass.color.setHex(0x8a6335);
        matLeaf1.color.setHex(0xcc5500); // orange
        matLeaf2.color.setHex(0xcc2200); // red
        matLeaf3.color.setHex(0xeedd22); // yellow
        matDirt.color.setHex(0x8b5a2b);
      } else if (currentSeason === 'Spring') {
        matGrass.color.setHex(0x66cc44);
        matDarkGrass.color.setHex(0x66cc44); // ensure dark grass matches aesthetic
        matLeaf1.color.setHex(0xffb7c5); // cherry blossom pink
        matLeaf2.color.setHex(0xff99bb); // darker pink
        matLeaf3.color.setHex(0x77ee55); // bright green
        matDirt.color.setHex(0xa0784a);
      } else { // Summer
        matGrass.color.setHex(0x5aaf3c);
        matDarkGrass.color.setHex(0x3d8a25);
        matLeaf1.color.setHex(0x3daa2a);
        matLeaf2.color.setHex(0x4dc535);
        matLeaf3.color.setHex(0x2d8a1a);
        matDirt.color.setHex(0xa0784a);
      }

      setRandomWeatherForSeason();
    }
    // Initialize lighting
    updateLighting();

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();

      // Update sun/moon orbit continuously
      // (Optional: time could advance automatically here, but we'll stick to slider control for now)
      updateLighting();
      const dt = Math.min((now - last) / 1000, 0.05);
      last = now;

      if (started) {
        const spd = keys['ShiftLeft'] || keys['ShiftRight'] ? RUN_SPEED : SPEED;
        const fwdH = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const rgtH = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

        if (flyMode) {
          // ---- FLY MODE ---- (no collisions)
          const fwd3 = new THREE.Vector3(
            -Math.sin(yaw) * Math.cos(pitch),
            Math.sin(pitch),
            -Math.cos(yaw) * Math.cos(pitch)
          );
          const mv = new THREE.Vector3();
          if (keys['KeyW'] || keys['ArrowUp']) mv.add(fwd3);
          if (keys['KeyS'] || keys['ArrowDown']) mv.sub(fwd3);
          if (keys['KeyA'] || keys['ArrowLeft']) mv.sub(rgtH);
          if (keys['KeyD'] || keys['ArrowRight']) mv.add(rgtH);
          if (keys['Space'] || keys['KeyE']) mv.y += 1;
          if (keys['KeyQ']) mv.y -= 1;
          if (mv.lengthSq() > 0) mv.normalize().multiplyScalar(FLY_SPEED * dt);
          playerPos.add(mv);

          // Keep Rapier body aligned if it exists
          if (playerBody) {
            const bodyY = playerPos.y - (EYE_HEIGHT - PLAYER_RADIUS);
            if (typeof playerBody.setTranslation === 'function') {
              playerBody.setTranslation({ x: playerPos.x, y: bodyY, z: playerPos.z }, true);
            }
            if (typeof playerBody.setLinvel === 'function') playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
          }

        } else {
          // ---- WALK MODE ---- (Rapier-driven)
          if (physWorld && playerBody) {
            const mv = new THREE.Vector3();
            if (keys['KeyW'] || keys['ArrowUp']) mv.add(fwdH);
            if (keys['KeyS'] || keys['ArrowDown']) mv.sub(fwdH);
            if (keys['KeyA'] || keys['ArrowLeft']) mv.sub(rgtH);
            if (keys['KeyD'] || keys['ArrowRight']) mv.add(rgtH);
            if (mv.lengthSq() > 0) mv.normalize();

            // Check if player is in water
            const playerLake = getLakeAtWater(playerPos.x, playerPos.z);
            const inWater = playerLake && playerPos.y < playerLake.level;
            const waterSpeedMult = inWater ? 0.5 : 1.0;  // Slower in water
            const actualSpd = spd * waterSpeedMult;

            // Ground check via raycast
            const origin = playerBody.translation();
            const ray = new RAPIER.Ray({ x: origin.x, y: origin.y, z: origin.z }, { x: 0, y: -1, z: 0 });
            const maxToi = PLAYER_HALF_HEIGHT + PLAYER_RADIUS + 0.12;
            const hit = physWorld.castRay(ray, maxToi, true);
            isGrounded = !!hit;

            const cur = playerBody.linvel();
            const desired = { x: mv.x * actualSpd, y: cur.y, z: mv.z * actualSpd };

            // Jump (weaker in water)
            if (keys['Space'] && isGrounded && (now - lastJumpTime) > 250) {
              desired.y = inWater ? JUMP_VEL * 0.5 : JUMP_VEL;
              lastJumpTime = now;
            }

            // Swim up in water
            if (inWater && keys['Space']) {
              desired.y = Math.max(desired.y, 4);
            }

            if (typeof playerBody.setLinvel === 'function') {
              playerBody.setLinvel(desired, true);
            } else if (typeof playerBody.setLinearVelocity === 'function') {
              playerBody.setLinearVelocity(desired, true);
            }

          } else {
            // Fallback old movement
            const mv = new THREE.Vector3();
            if (keys['KeyW'] || keys['ArrowUp']) mv.add(fwdH);
            if (keys['KeyS'] || keys['ArrowDown']) mv.sub(fwdH);
            if (keys['KeyA'] || keys['ArrowLeft']) mv.sub(rgtH);
            if (keys['KeyD'] || keys['ArrowRight']) mv.add(rgtH);
            if (mv.lengthSq() > 0) mv.normalize().multiplyScalar(spd * dt);
            playerPos.x += mv.x;
            playerPos.z += mv.z;

            const groundY = sampleGround(playerPos.x, playerPos.z) + EYE_HEIGHT;
            velY += GRAVITY_ACC * dt;
            playerPos.y += velY * dt;
            if (playerPos.y < groundY) {
              playerPos.y = groundY;
              isGrounded = true;
              velY = 0;
            } else {
              isGrounded = false;
            }
            if (keys['Space'] && isGrounded) {
              velY = JUMP_VEL;
              isGrounded = false;
            }
          }
        }
      }

      camera.position.copy(playerPos);
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      updateWaterViewState();

      document.getElementById('ui').textContent = flyMode
        ? 'ğŸ•Šï¸ ××¦×‘ ×˜×™×¡×” â€” F ×œ×‘×™×˜×•×œ | E/Space ×¢×œ×” | Q ×¨×“'
        : (isLocked ? 'ğŸŒ¿ Lowpoly World â€” ESC ×œ×©×—×¨×¨ ×¢×›×‘×¨' : 'ğŸŒ¿ ×œ×—×¥ ×œ×”× ×¢×œ×ª ×¢×›×‘×¨');

      updateChunks(playerPos.x, playerPos.z);

      for (const b of birds) {
        b.userData.t += dt;
        const d = b.userData;
        d.angle += d.speed;
        const tx = playerPos.x + Math.cos(d.angle) * d.rad;
        const tz = playerPos.z + Math.sin(d.angle) * d.rad;
        b.position.x += (tx - b.position.x) * 0.01;
        b.position.z += (tz - b.position.z) * 0.01;
        b.position.y = d.height + Math.sin(d.t * 0.7) * 3;
        b.lookAt(b.position.x + Math.cos(d.angle + Math.PI / 2), b.position.y, b.position.z + Math.sin(d.angle + Math.PI / 2));
        const fa = Math.sin(d.t * d.flapSpeed) * d.flapAmp;
        b.children[0].rotation.z = Math.PI / 2 + fa;
        b.children[1].rotation.z = -Math.PI / 2 - fa;
      }

      // Animate dancing balls in starting lake
      const animTime = performance.now() / 1000;
      animateDancingBalls(animTime, dt);

      // Update foam system (splash + waterline foam)
      updateFoamSystem(dt);

      // Sun and shadows are completely fixed in world space - no movement
      // Sun disc and glow positions are set once at initialization

      // Step physics
      stepPhysics(dt);

      renderFrame();
    }

    // ============================================================
    // RAPIER PHYSICS - loaded via dynamic ESM import
    // ============================================================
    let RAPIER = null;
    let physWorld = null;
    const rigidBodies = []; // {mesh, body}
    const projectiles = []; // {mesh, body, born}

    // Terrain colliders per chunk (static) so bullets don't fall through visual ground
    const terrainColliders = new Map(); // key -> RAPIER.Collider

    // Static colliders for decorations (trees/rocks/bushes) so projectiles/blocks collide with them.
    // For performance and simplicity these are fixed colliders (no rigid bodies).
    const decorationColliders = []; // RAPIER.Collider[]
    let decorationsDirty = false;

    // map from Three.js mesh -> rigid body for easy lookup
    const meshToBody = new Map();

    async function loadRapier() {
      // jsdelivr ESM URL for rapier3d-compat 0.14.0 (stable, widely cached)
      const R = await import('https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js');
      await R.init();
      RAPIER = R;

      // Create world
      physWorld = new RAPIER.World({ x: 0, y: -25, z: 0 });

      // NOTE:
      // We intentionally don't use a single flat ground plane.
      // Instead, each rendered terrain chunk gets its own static collider,
      // matching the visual mesh so projectiles don't fall through.

      console.log('âœ“ Rapier physics ready');

      // Create colliders for decorations already created before Rapier loaded
      clearDecorationColliders();
      for (const [, grp] of objects) addDecorationCollidersFromGroup(grp);

      initPlayerPhysics();

      buildTower();

      // Add physics to dancing balls after Rapier is loaded
      addDancingBallsPhysics();
    }

    function addPhysicsBox(mesh, hw, hh, hd, mass) {
      const t = mesh.position;
      const q = mesh.quaternion;
      let bodyDesc = mass === 0
        ? RAPIER.RigidBodyDesc.fixed()
        : RAPIER.RigidBodyDesc.dynamic();
      bodyDesc.setTranslation(t.x, t.y, t.z);
      bodyDesc.setRotation({ x: q.x, y: q.y, z: q.z, w: q.w });

      // Extra damping helps stacks settle instead of jittering/drifting.
      if (mass !== 0) {
        if (typeof bodyDesc.setLinearDamping === 'function') bodyDesc.setLinearDamping(0.15);
        if (typeof bodyDesc.setAngularDamping === 'function') bodyDesc.setAngularDamping(0.25);
      }

      const body = physWorld.createRigidBody(bodyDesc);
      const colDesc = RAPIER.ColliderDesc.cuboid(hw, hh, hd)
        .setRestitution(0.05)
        .setFriction(0.9);
      physWorld.createCollider(colDesc, body);
      rigidBodies.push({ mesh, body });
      meshToBody.set(mesh, body);
      return body;
    }

    function addPhysicsSphere(mesh, r, mass) {
      const t = mesh.position;
      const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(t.x, t.y, t.z);
      const body = physWorld.createRigidBody(bodyDesc);

      // Apply mass by setting density (Rapier uses collider density to derive mass).
      // Without this, bullets can feel like they "drop" immediately due to being too light.
      const density = Math.max(0.1, mass); // treat 'mass' as density-like scalar
      const colDesc = RAPIER.ColliderDesc.ball(r)
        .setDensity(density)
        .setRestitution(0.35)
        .setFriction(0.4);

      physWorld.createCollider(colDesc, body);
      rigidBodies.push({ mesh, body });
      return body;
    }

    function clearDecorationColliders() {
      if (!physWorld) return;
      for (const c of decorationColliders) {
        physWorld.removeCollider(c, true);
      }
      decorationColliders.length = 0;
    }

    function addDecorationCollidersFromGroup(group) {
      if (!physWorld || !RAPIER || !group) return;

      // Simple & fast: approximate each mesh in the decoration group with an oriented bounding box collider.
      // This is not perfect but gives solid physical interaction.
      const meshes = [];
      group.traverse(obj => { if (obj && obj.isMesh) meshes.push(obj); });

      for (const m of meshes) {
        const geo = m.geometry;
        if (!geo) continue;
        if (!geo.boundingBox) geo.computeBoundingBox();
        const bb = geo.boundingBox;
        if (!bb) continue;

        const size = new THREE.Vector3();
        bb.getSize(size);
        const center = new THREE.Vector3();
        bb.getCenter(center);

        // World transform
        const worldPos = new THREE.Vector3();
        m.getWorldPosition(worldPos);
        const worldQuat = new THREE.Quaternion();
        m.getWorldQuaternion(worldQuat);

        // Bounding box center in world space
        const worldCenter = center.clone().applyQuaternion(worldQuat).add(worldPos);

        // Use scaled half-extents (avoid zeros)
        const sx = m.scale.x || 1, sy = m.scale.y || 1, sz = m.scale.z || 1;
        const hx = Math.max(0.05, size.x * 0.5 * sx);
        const hy = Math.max(0.05, size.y * 0.5 * sy);
        const hz = Math.max(0.05, size.z * 0.5 * sz);

        const colDesc = RAPIER.ColliderDesc.cuboid(hx, hy, hz)
          .setTranslation(worldCenter.x, worldCenter.y, worldCenter.z)
          .setRotation({ x: worldQuat.x, y: worldQuat.y, z: worldQuat.z, w: worldQuat.w })
          .setRestitution(0.05)
          .setFriction(0.9);

        const col = physWorld.createCollider(colDesc);
        decorationColliders.push(col);
      }
    }

    function buildTower() {
      if (!RAPIER) return;
      // Remove old
      for (const rb of rigidBodies) { scene.remove(rb.mesh); physWorld.removeRigidBody(rb.body); }
      rigidBodies.length = 0;
      for (const p of projectiles) scene.remove(p.mesh);
      projectiles.length = 0;
      meshToBody.clear();

      // Ensure colliders exist for currently visible chunks (Rapier may load after terrain render)
      for (const [key, mesh] of chunks) {
        if (terrainColliders.has(key)) continue;
        const geo = mesh.geometry;
        const parts = key.split(',').map(Number);
        const cx = parts[0], cz = parts[1];
        const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;

        if (physWorld && RAPIER) {
          const posAttr = geo.getAttribute('position');
          const idxAttr = geo.index;

          const verts = new Float32Array(posAttr.count * 3);
          for (let i = 0; i < posAttr.count; i++) {
            verts[i * 3 + 0] = posAttr.getX(i);
            verts[i * 3 + 1] = posAttr.getY(i);
            verts[i * 3 + 2] = posAttr.getZ(i);
          }

          let indices;
          if (idxAttr) {
            indices = new Uint32Array(idxAttr.count);
            for (let i = 0; i < idxAttr.count; i++) indices[i] = idxAttr.getX(i);
          } else {
            indices = new Uint32Array(posAttr.count);
            for (let i = 0; i < posAttr.count; i++) indices[i] = i;
          }

          const colDesc = RAPIER.ColliderDesc.trimesh(verts, indices)
            .setTranslation(ox, 0, oz)
            .setRestitution(0.0)
            .setFriction(0.9);
          const collider = physWorld.createCollider(colDesc);
          terrainColliders.set(key, collider);
        }
      }

      // Place tower in front of player
      const fwd = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      const gx = playerPos.x + fwd.x * 14;
      const gz = playerPos.z + fwd.z * 14;
      const gy = sampleGround(gx, gz);

      // Ground slab under tower (static)
      // Use a LEVEL foundation so the stack starts stable even if the terrain below is sloped.
      const SLAB_CLEARANCE = 0.55;
      const slabGeo = new THREE.BoxGeometry(12, 0.5, 6);
      const slabMat = new THREE.MeshPhongMaterial({ color: 0x8a7060, flatShading: true });
      const slabMesh = new THREE.Mesh(slabGeo, slabMat);
      slabMesh.receiveShadow = true;
      slabMesh.castShadow = true;
      slabMesh.position.set(gx, gy + 0.25 + SLAB_CLEARANCE, gz);
      slabMesh.rotation.set(0, 0, 0);
      scene.add(slabMesh);
      addPhysicsBox(slabMesh, 6, 0.25, 3, 0); // static

      // Colored blocks
      const bw = 0.6, bh = 0.6, bd = 0.6;
      const wide = 4, tall = 7;
      const BLOCK_CLEARANCE = 0.28;
      const cols = [0xe74c3c, 0xe67e22, 0xf1c40f, 0x2ecc71, 0x3498db, 0x9b59b6, 0x1abc9c, 0xe91e63];
      for (let row = 0; row < tall; row++) {
        for (let col = 0; col < wide; col++) {
          const wx = gx + (col - (wide - 1) / 2) * (bw * 2 + 0.05);
          const wy = gy + 0.3 + bh + row * (bh * 2 + 0.01) + SLAB_CLEARANCE + BLOCK_CLEARANCE;
          const color = cols[(row * wide + col) % cols.length];
          const geo = new THREE.BoxGeometry(bw * 2, bh * 2, bd * 2);
          const mat = new THREE.MeshPhongMaterial({ color, flatShading: true, shininess: 8 });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.castShadow = mesh.receiveShadow = true;
          mesh.position.set(wx, wy, gz);
          scene.add(mesh);
          addPhysicsBox(mesh, bw, bh, bd, 3);
        }
      }
      console.log('âœ“ Tower built:', rigidBodies.length, 'bodies');
    }

    function shoot() {
      if (!RAPIER || !isLocked) return;

      const R = 0.25;
      const MUZZLE_SPEED = 65; // higher speed so it clearly goes forward

      // Direction from camera (includes pitch)
      const dir = new THREE.Vector3(
        -Math.sin(yaw) * Math.cos(pitch),
        Math.sin(pitch),
        -Math.cos(yaw) * Math.cos(pitch)
      ).normalize();

      // Spawn slightly in front of the camera, and not intersecting the player/ground
      const sp = camera.getWorldPosition(new THREE.Vector3())
        .addScaledVector(dir, 2.2);

      const geo = new THREE.SphereGeometry(R, 10, 7);
      const mat = new THREE.MeshPhongMaterial({ color: 0x1a1a2e, flatShading: true, shininess: 60 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.position.copy(sp);
      scene.add(mesh);

      const body = addPhysicsSphere(mesh, R, 4);

      // Ensure it doesn't start "asleep" and add a small upward bias so it doesn't feel like it drops from you
      // Rapier JS API differs between builds. Support both:
      // - setLinvel({x,y,z}, wakeUp)
      // - setLinearVelocity({x,y,z}, wakeUp)
      // Also wake explicitly where supported.
      const linvel = {
        x: dir.x * MUZZLE_SPEED,
        y: (dir.y + 0.03) * MUZZLE_SPEED,
        z: dir.z * MUZZLE_SPEED,
      };

      if (typeof body.wakeUp === 'function') body.wakeUp();

      if (typeof body.setLinvel === 'function') {
        body.setLinvel(linvel, true);
      } else if (typeof body.setLinearVelocity === 'function') {
        body.setLinearVelocity(linvel, true);
      } else {
        console.warn('RigidBody has no linear-velocity setter. Available keys:', Object.keys(body));
      }

      // High CCD for fast projectile
      if (typeof body.enableCcd === 'function') body.enableCcd(true);

      projectiles.push({ mesh, body, born: performance.now() });
    }

    // Sync Three.js meshes with Rapier body transforms
    function stepPhysics(dt) {
      if (!physWorld) return;

      // Rebuild decoration colliders in a controlled place (once) if chunks changed.
      if (decorationsDirty) {
        decorationsDirty = false;
        clearDecorationColliders();
        for (const [, g] of objects) addDecorationCollidersFromGroup(g);
      }
      physWorld.timestep = dt;
      physWorld.step();

      // Apply water physics to all rigid bodies
      for (const rb of rigidBodies) {
        if (rb.body.isFixed()) continue;
        const t = rb.body.translation();
        const r = rb.body.rotation();
        rb.mesh.position.set(t.x, t.y, t.z);
        rb.mesh.quaternion.set(r.x, r.y, r.z, r.w);

        // Check if in water
        const lake = getLakeAtWater(t.x, t.z);
        if (lake && t.y < lake.level) {
          const vel = rb.body.linvel();
          const waterDrag = 0.88;
          const buoyancy = 3.5;

          const newVel = {
            x: vel.x * waterDrag,
            y: vel.y * waterDrag + buoyancy * dt,
            z: vel.z * waterDrag
          };

          if (typeof rb.body.setLinvel === 'function') {
            rb.body.setLinvel(newVel, false);
          }
        }
      }

      // Apply water physics to projectiles
      for (const p of projectiles) {
        const t = p.body.translation();
        const lake = getLakeAtWater(t.x, t.z);

        if (lake && t.y < lake.level) {
          // Object is in water - apply drag and buoyancy
          const vel = p.body.linvel();
          const waterDrag = 0.92;  // Slow down in water
          const buoyancy = 2.5;    // Upward force

          // Apply water drag (slow down horizontal movement)
          const newVel = {
            x: vel.x * waterDrag,
            y: vel.y * waterDrag + buoyancy * dt,  // Buoyancy pushes up
            z: vel.z * waterDrag
          };

          if (typeof p.body.setLinvel === 'function') {
            p.body.setLinvel(newVel, false);
          }

          // Change projectile color when in water
          if (p.mesh.material.color.getHex() !== 0x1a4a6e) {
            p.mesh.material.color.setHex(0x1a4a6e);
          }
        }
      }

      // Sync player camera position from Rapier body
      if (playerBody) {
        const tp = playerBody.translation();
        // Body translation is capsule center; playerPos is eye position.
        playerPos.set(tp.x, tp.y + (EYE_HEIGHT - PLAYER_RADIUS), tp.z);
      }

      // Projectiles are kept (no auto-despawn).
      // Note: Keeping unlimited bodies forever can eventually hurt performance.
      // If you ever want a limit, we can keep the last N projectiles instead.
    }
    // ============================================================
    // BOOT
    // ============================================================
    updateChunks(0, 0);
    const startH = getTerrainY(0, 0) + EYE_HEIGHT + 1;
    playerPos.set(0, startH, 0);
    updateWaterViewState();

    // Create dancing balls in starting lake after chunks are loaded
    createDancingBalls();

    // Shoot on left click
    renderer.domElement.addEventListener('mousedown', e => {
      if (!started || !isLocked) return;
      if (e.button === 0) shoot();
    });

    // R = rebuild tower
    document.addEventListener('keydown', e => {
      if (e.code === 'KeyR') buildTower();
    });

    // Load Rapier and build tower
    function initPlayerPhysics() {
      if (!physWorld || !RAPIER) return;

      // Remove old player if any
      if (playerBody) {
        physWorld.removeRigidBody(playerBody);
        playerBody = null;
        playerCollider = null;
      }

      const start = playerPos.clone();
      const bodyY = start.y - (EYE_HEIGHT - PLAYER_RADIUS);

      const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(start.x, bodyY, start.z);

      // Prevent tipping over
      if (typeof bodyDesc.lockRotations === 'function') bodyDesc.lockRotations();

      // Damping for stable character control
      if (typeof bodyDesc.setLinearDamping === 'function') bodyDesc.setLinearDamping(4.0);
      if (typeof bodyDesc.setAngularDamping === 'function') bodyDesc.setAngularDamping(4.0);

      playerBody = physWorld.createRigidBody(bodyDesc);

      // Collider
      let colDesc;
      if (RAPIER.ColliderDesc.capsule) {
        colDesc = RAPIER.ColliderDesc.capsule(PLAYER_HALF_HEIGHT, PLAYER_RADIUS);
      } else {
        // Fallback
        colDesc = RAPIER.ColliderDesc.ball(PLAYER_RADIUS);
      }

      colDesc.setFriction(0.0).setRestitution(0.0);
      playerCollider = physWorld.createCollider(colDesc, playerBody);
    }

    loadRapier().catch(err => console.error('Rapier load failed:', err));

    window.render_game_to_text = () => JSON.stringify({
      mode: started ? (flyMode ? 'fly' : 'walk') : 'menu',
      controlsLocked: isLocked,
      player: {
        x: Number(playerPos.x.toFixed(2)),
        y: Number(playerPos.y.toFixed(2)),
        z: Number(playerPos.z.toFixed(2)),
        yaw: Number(yaw.toFixed(3)),
        pitch: Number(pitch.toFixed(3))
      },
      nearby: {
        loadedChunks: chunks.size,
        rigidBodies: rigidBodies.length,
        projectiles: projectiles.length,
        lakes: lakes.size,
        birds: birds.length
      },
      coordinateSystem: 'Right-handed; +X right, +Y up, +Z toward south (camera looks to -Z by default).'
    });

    window.advanceTime = (ms = 16.67) => {
      const dt = Math.min(Math.max(ms, 1) / 1000, 0.05);
      stepPhysics(dt);
      updateChunks(playerPos.x, playerPos.z);
      camera.position.copy(playerPos);
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      updateWaterViewState();
      renderFrame();
    };

    async function boot() {
      try {
        if (typeof renderer.init === 'function') {
          await renderer.init();
        }
      } catch (err) {
        showWebGPUError('× ×›×©×œ ××ª×—×•×œ WebGPU. ×”×¨×¥ ×“×¨×š localhost/https ×•× ×¡×” ×“×¨×™×™×‘×¨/×“×¤×“×¤×Ÿ ×¢×“×›× ×™.');
        console.error('WebGPU init failed:', err);
        return;
      }
      animate();
    }

    boot();
  </script>
</body>

</html>